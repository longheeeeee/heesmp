# 1. 码良：
## 1.1 码良页面优化：
### 1. 针对码良特性做的优化：
  1. 组件合并，封装js包，减少请求，页面配置放在html上
  2. 增加组件版本合并工具，减少组件版本差异，减少冗余代码
### 2. 针对通用页面做的优化：
  1. 优化埋点，埋点转化成简单请求，延后不必要的埋点，首屏不发送埋点
  2. 图片懒加载，优化图片体积，因为CDN使用的是http2协议，所以不需要新增多个域名，压缩图片。尽量使用jpeg而不是带有a层的png。尝试使用webp格式，可以使用picture进行优雅降级
  3. 整理流程，延后没必要的SDK的加载
  4. 优化组件，头像组件图片上云，vue做external，地址数据上云
  5. 添加各个域名的prefetch，提前创建http连接
### 3. 海外专项优化
  因为cdn在海外没有服务器，所以海外访问需要耗费大量时间在网络上，所以
  1. 添加了海外CDN加速，所有的静态资源都放在CDN上，包括html和css，因为使用了http2协议，所以不需要考虑统一域名的连接数量问题，可以有效提高并发数量和减少DNS查询时间
  2. 添加一台服务器在香港，使用专线对接深圳源服务器，能缩短链路，减少网络拥堵

## 1.2 关于图片：
### 懒加载实现方式：
  1. 监听scroll，获取所有的img标签，然后遍历计算是否有img标签的位置在bodyScrollTop加上bodyHeight范围内，如果有就把img的_src属性赋值给src属性
  2. 使用intersectionObserver api实现，把所有的img都添加上监听，当api触发的时候代表跟body发生了交叉，然后就去替换掉图片的链接，然后取消监听
### webp兼容实现方式：
  1. 在CDN上添加边缘脚本，当用户的accept-type包含webp格式的时候，返回添加了参数转成webp格式的阿里云图片
  2. 使用picture标签，添加source并且设置格式为`image/webp`，最后img标签写的是jpeg的图片地址，这样子浏览器就可以自动根据兼容性来选择加载的图片


# 2. 微前端
## 2.1 封装组件，创建cli工具和模板
- 为了减少原有项目接入时候的工作量，在项目传入qiankun的配置装了一层封装，把一些通用的配置整合到项目的钩子函数中，比如主应用用户权限的下发，包括在开发环境子应用单独运行下的用户权限请求和返回处理，子应用修改主应用状态的方法，因为qiankun推荐的方法为了兼容性考虑，使用起来稍显复杂和局限，而我们的项目在技术栈上都差不多，而且需要开放修改的主应用数据不多，所以选择的是封装一系列调用主应用store上的action的方法到子应用上
- 在webpack上做了一层封装，添加了一些通用的配置，比如微前端的publicPath，公用环境变量，组件更新等配置
- 构建cli工具，整理了一些常用项目的模板，比如子应用的模板，组件的模板等。

## 2.2 权限系统


## 2.3 通过refreshToken自动刷新accessToken
- 公司的项目在微前端接入之前，都是各自业务线维护自己的登录鉴权，并且前端的实现都不统一，有使用session cookie的也有token的，接入微前端的同时也创建了一个用户中心的服务，把公司的用户信息和鉴权服务都统一了，但是对每个子应用都封装新的鉴权和刷新机制工作量太大，所以选择在主应用处添加一个拦截XHR的组件，用于往请求上添加授权头和处理异常请求。
- 请求发出之前会被拦截，添加上accessToken，发出然后存到队列里，请求正常返回后从队列里删除；当请求返回403代表token过期的时候，会设置标志锁住队列，后面再进来的请求推进队列里，然后不允许发出，之前发出的请求也拦截住，直接丢弃，不返回给业务代码，然后使用refreshToken去刷新token，刷新成功了取消标志，重新把队列里的请求使用新的token重新发起请求
- 优点是对目前的代码改动小，利于子应用的接入，子应用不需要关心这部分逻辑

## 2.4 用户本地自定义菜单
用户自定义本地菜单，包括菜单的位置，显隐等信息，参考了vue中的patch的相关思想，正常使用下本地没有自定义菜单缓存，如果用户修改过就会生成一份，当用户再次打开应用的时候会向后端请求一份新的菜单数据，然后进行比对进行本地菜单的更新，因为只允许同层移动，所以只需要对同层节点进行对比，根据旧数组的菜单id生成map，遍历新数组进行比对，需要更新的，新增或者删除的都推进一个数组里，最后遍历这个数组进行统一处理