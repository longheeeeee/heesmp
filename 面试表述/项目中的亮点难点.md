# 1. 码良：
码良这个项目是在开源框架上做二次迭代的，项目的核心是动态组件、递归组件、DSL结构设计，但是针对核心技术上没有改动到太多，我们主要的工作有配置化、可视化交互、业务能力开发三个方面，其中重点在后面两个。实际上我们做了三个点，接入统一登录权限，实现权限角色配置化、界面交互优化，让运营人员可以自己解决大部分需求、业务组件开发。

## 1.1 接入统一登录权限
码良系统自带了登录系统，系统只有管理员用户两种角色，并且是按照业务线进行划分，公司的统一登录是用户加角色，技术上没有业务线的划分，要打通两边的权限，我们在码良上设定了每个业务线下都有三种角色，开发，运营和管理员，用户在登录的时候会带上统一登录的token，根据token调用登录接口，接口查出用户信息后在码良上创建一个新的用户，并且更新对应的权限，再次登录会查找用户已有权限，把新的权限的业务线id和最高权限生成哈希表，遍历旧的权限，把新增、删除、更新的角色权限推进队列，最后统一修改。

## 1.2 界面交互优化
- 系统的使用者主要分成运营人员和业务线开发人员，开发人员进行组件的调试和新页面的开发，运营人员在已有页面的基础上进行复制、修改和发布，因为双方的侧重点不一样，所以需要进行区分。
- 因为码良这个系统设计上偏重于技术人员快速搭建页面，其中有着相当高的自由度，事件的触发、数据的流向都可以使用js脚本来编写，样式修改使用css设置、位置移动需要考虑margin还是top，都需要相关知识，所以对于运营人员来说门槛太高，他们对于页面的修改不需要太复杂，我们可以把能遇见的修改都放在组件里面作为参数暴露出去
- 通过和产品运营人员的沟通和对其他系统的参考，我们把常用的事件和数据使用事件中心和vuex状态管理内置到码良系统上，屏蔽了很多需要技术门槛的功能，并且同使用人员进行了宣发，紧跟反馈，确认迭代方向

## 1.3 规范业务组件开发
- 对于开发人员而言，我们定下了一些规范和默认配置，比如封装了弹窗、http请求方法和各业务线的地址，内置了一些ui组件和常用的库，对于数据共享和事件的触发做了一些规定，并且做了模板，开发人员通过脚手架拉取模版后就能直接开发。
- 根据目前的情况做了一些通用组件，简单的比如轮播、图片、按钮等，复杂的有微信授权，支付等。
- 优化组件联调，通过配置替换掉某个组件的地址，改成开发人员本地地址，实现联调
- 配置代码babel转换，对于一些在平台上直接编辑的js代码，在发布前使用babel进行一层转换，适配es5

## 1.4 码良页面优化：
### 1. 针对码良特性做的优化：
  1. 组件合并，封装js包，减少请求，页面配置放在html上
  2. 增加组件版本合并工具，减少组件版本差异，减少冗余代码
### 2. 针对通用页面做的优化：
  1. 优化埋点，埋点转化成简单请求，延后不必要的埋点，首屏不发送埋点
  2. 图片懒加载，优化图片体积，因为CDN使用的是http2协议，所以不需要新增多个域名，压缩图片。尽量使用jpeg而不是带有a层的png。尝试使用webp格式，可以使用picture进行优雅降级
  3. 整理流程，延后没必要的SDK的加载
  4. 优化组件，头像组件图片上云，vue做external，地址数据上云
  5. 添加各个域名的prefetch，提前创建http连接
### 3. 海外专项优化
  因为cdn在海外没有服务器，所以海外访问需要耗费大量时间在网络上，所以
  1. 添加了海外CDN加速，所有的静态资源都放在CDN上，包括html和css，因为使用了http2协议，所以不需要考虑统一域名的连接数量问题，可以有效提高并发数量和减少DNS查询时间
  2. 添加一台服务器在香港，使用专线对接深圳源服务器，能缩短链路，减少网络拥堵

## 1.5 关于图片：
### 懒加载实现方式：
  1. 监听scroll，获取所有的img标签，然后遍历计算是否有img标签的位置在bodyScrollTop加上bodyHeight范围内，如果有就把img的_src属性赋值给src属性
  2. 使用intersectionObserver api实现，把所有的img都添加上监听，当api触发的时候代表跟body发生了交叉，然后就去替换掉图片的链接，然后取消监听
### webp兼容实现方式：
  1. 在CDN上添加边缘脚本，当用户的accept-type包含webp格式的时候，返回添加了参数转成webp格式的阿里云图片
  2. 使用picture标签，添加source并且设置格式为`image/webp`，最后img标签写的是jpeg的图片地址，这样子浏览器就可以自动根据兼容性来选择加载的图片

## 1.6 页面生成
- 原本的页面展示过程：
打开页面，带上pagekey，页面加载，根据pagekey获取页面配置，加载页面配置，生成组件树，节点组件异步加载对应的组件，然后等待各个组件代码加载，完成展示
- 问题：
根据page获取页面的时候会阻塞后面过程，后面组件加载会造成大量请求。问题就是两个地方，我们可以把两个地方都简化一下，页面配置可以直接放到html上，组件代码可以打包
- 优化
用户发布页面的时候，服务器首先拉取基础的页面HTML文件，然后遍历页面配置，获得所有的组件地址，并且发起请求获取，获取完成后放到同一个js文件中，最后把页面配置封装一层，使用一个函数放到window上，并且使用script插入到html中，最终生成一个html和一个js文件。

页面打开的时候会加载打包后的组件js文件，js加载后再执行初始化，此时因为页面配置已经在window上了，可以直接生成页面，等到节点组件加载组件的时候，因为组件代码也已经加载完成了，就可以直接在缓存中获取，不需要发请求。这样子就可以节省配置请求和浓缩多个组件请求到一个上。

## 1.7 动态组件，递归组件，DSL结构字段设计
#### DSL结构字段设计：
在系统上通过选择组件并且插入的方式生成页面，最终生成的DSL结构是树状的，每一个节点代表一个组件，结构中描述了以下几大类：
1. 组件基本信息：组件的名称，加载地址，版本等信息
2. 样式信息：每个组件都能通过控件调整或者手写CSS代码生成style描述
3. 组件配置：组件暴露出去的配置在用户进行配置后存在props字段
4. event事件绑定配置：以数组形式存储，每一个元素代表绑定在这个组件上的事件，还有对应事件的回调列表，回调列表中保存着其他组件方法的路径，组件内部使用封装的事件进行触发，事件中心会根据id查找对应组件并且依次触发回调
5. 组件混入：系统支持直接写mixin脚本，可以根据不同的情况添加配置，比如给部分图片添加点击事件，所有的脚本存放在script数组上，在组件生成的时候会进行混入。
#### 递归组件：
页面拿到配置后，会递归配置并且生成组件树，每一个节点都会渲染一个通用的Node组件，然后Node组件内部根据对应节点的组件配置，异步加载组件，然后在子递归组件的同级使用`<component>`渲染配置组件，最终生成的结果像一棵圣诞树，树上每一个分支上都挂着一个配件，实际上是通用Node组件生成的树上每一个节点都挂载自己的组件
#### 动态组件：
Node组件调用加载器加载组件，加载器根据组件地址异步加载到组件代码后根据组件名称进行缓存，然后注册组件，注册组件的时候会获取到传入的script配置，添加代码使执行完的代码放到window上，然后使用babel转译后执行，获取到配置后迭代使用extend进行继承后使用Vue.component挂载


## 1.8 存在的问题
1. 组件使用了提前编译，无法做公共代码提取，模块复用能力差。模块重复打包存在多实例不共享风险。
2. 目前的移动端适配方案比较恶心。

### 1.8.1 适配方案是什么
我们所有的页面都根据375的宽度进行配置，在页面打开的时候，使用window.screen.width获取屏幕逻辑像素宽度，然后除以375获得比例，然后添加meta标签，设置name=vireport，content为width=375，initial-scale、maximum-scale、mininum-scale设置成逻辑像素宽度和375的比例，来实现所有设备上的适配
- 问题：因为是使用缩放强行适配，所以在ipad等宽度比较大的设备或者pc上会很难用，很多地方需要做特殊处理，耗费时间

# 2. 微前端
## 2.1 封装组件，创建cli工具和模板
- 为了减少原有项目接入时候的工作量，在项目传入qiankun的配置装了一层封装，把一些通用的配置整合到项目的钩子函数中，比如主应用用户权限的下发，包括在开发环境子应用单独运行下的用户权限请求和返回处理，子应用修改主应用状态的方法，因为qiankun推荐的方法为了兼容性考虑，使用起来稍显复杂和局限，而我们的项目在技术栈上都差不多，而且需要开放修改的主应用数据不多，所以选择的是封装一系列调用主应用store上的action的方法到子应用上
- 在webpack上做了一层封装，添加了一些通用的配置，比如微前端的publicPath，公用环境变量，组件更新等配置
- 构建cli工具，整理了一些常用项目的模板，比如子应用的模板，组件的模板等。

## 2.2 权限系统
权限系统有五个实体，分别是用户，角色，数据权限，菜单，资源，其中菜单分成普通菜单和组件。
1. 用户拥有多个角色，用户和角色的绑定关系上还有数据权限
2. 每个角色可以绑定多个菜单或者组件
3. 菜单下面可以有多个子菜单或者组件，菜单的根节点是子应用
4. 菜单或者组件下面可以有多个资源，资源即后端API，可以细分到不同的参数

权限系统的使用流程：
1. 用户打开页面的时候会根据用户的角色，返回qiankun所使用的子应用的入口地址和用户的菜单组件权限
2. 主应用拿到菜单后渲染菜单，子应用加载的时候拿到菜单动态添加到路由表上，并且根据菜单下的按钮权限显示按钮
3. 用户调用接口是在网关进行拦截和权限校验，没有权限的会返回403

## 2.3 通过refreshToken自动刷新accessToken
- 公司的项目在微前端接入之前，都是各自业务线维护自己的登录鉴权，并且前端的实现都不统一，有使用session cookie的也有token的，接入微前端的同时也创建了一个用户中心的服务，把公司的用户信息和鉴权服务都统一了，但是对每个子应用都封装新的鉴权和刷新机制工作量太大，所以选择在主应用处添加一个拦截XHR的组件，用于往请求上添加授权头和处理异常请求。
- 请求发出之前会被拦截，添加上accessToken，发出然后存到队列里，请求正常返回后从队列里删除；当请求返回403代表token过期的时候，会设置标志锁住队列，后面再进来的请求推进队列里，然后不允许发出，之前发出的请求也拦截住，直接丢弃，不返回给业务代码，然后使用refreshToken去刷新token，刷新成功了取消标志，重新把队列里的请求使用新的token重新发起请求
- 优点是对目前的代码改动小，利于子应用的接入，子应用不需要关心这部分逻辑

## 2.4 用户本地自定义菜单
用户自定义本地菜单，包括菜单的位置，显隐等信息，参考了vue中的patch的相关思想，正常使用下本地没有自定义菜单缓存，如果用户修改过就会生成一份，当用户再次打开应用的时候会向后端请求一份新的菜单数据，然后进行比对进行本地菜单的更新，因为只允许同层移动，所以只需要对同层节点进行对比，根据旧数组的菜单id生成map，遍历新数组进行比对，需要更新的，新增或者删除的都推进一个数组里，最后遍历这个数组进行统一处理

# 3. 遇到什么问题：
遇到的比较大的问题是一个性能问题，之前一直在国内投放，投放量级也比较小，所以之前性能不怎么特别关心，然后计划在海外投放的时候，产品测了一下海外性能，发现问题比较大，基本上LCP在5s左右，部分能上到10s。

于是先本地使用性能分析工具测试，发现不少问题：
#### 图片上
1. 图片没有做懒加载，添加懒加载方案
2. 图片格式使用png，体积比较大，使用webp
#### 平台组件上
1. 组件版本不一样导致代码冗余，增加组件版本检测，在页面发布前提示
2. 组件优化，部分组件没有做external，头像组件图片上云，地址组件数据上云
3. 被运营人员隐藏的，没有使用到的组件做删减
#### 业务上
1. 埋点请求阻塞：埋点修改成简单请求（后端不支持图片），延后埋点发送时机，减少不必要埋点。
2. 整理流程，延后没必要的SDK，比如极光sdk、google广告回传sdk等

完成后，本地加载速度已经变快很多了，本地测试LCP时间大概在1s以内。然后重新使用海外性能分析工具测试，发现时间还是不太理想，而且还发现了几个问题：
1. 网络问题太突出，网络时间太长，dns和连接时间占了400+ms
2. 首屏下载文件在源站，使用http1.1协议，数量刚好是七个，导致排队

因为图片我们已经部署了CDN了，发现效果没那么好，后来发现应该是没有部署海外节点，所以针对网络问题加多了两个步骤：
1. 添加了海外CDN加速来减少加载时间
2. 把html资源和图片资源都换成同一个域名，减少dns查找时间
3. 添加一个香港服务器，通过专线转到深圳服务器，减少出口拥堵

最后测试下来，LCP能稳定到2s多，因为接口还是需要回源，所以请求数据的接口相对还是会慢一点


### 懒加载实现方式：
  1. 监听scroll，获取所有的img标签，然后遍历计算是否有img标签的位置在bodyScrollTop加上bodyHeight范围内，如果有就把img的_src属性赋值给src属性
  2. 使用`intersectionObserver` api实现，把所有的img都添加上监听，当api触发的时候代表跟body发生了交叉，然后就去替换掉图片的链接，然后取消监听
### webp兼容实现方式：
  1. 在CDN上添加边缘脚本，当用户的accept-type包含webp格式的时候，返回添加了参数转成webp格式的阿里云图片
  2. 使用picture标签，添加source并且设置格式为`image/webp`，最后img标签写的是jpeg的图片地址，这样子浏览器就可以自动根据兼容性来选择加载的图片


# 4. 遇到什么问题2:
### 业务场景
业务场景是这样的，有一个页面，里面包含了几个不一定会显示的子组件，所有的子组件都赖于一个用户信息userinfo，因为父组件不需要这恶搞u色如I你佛，所以我把这个获取逻辑放到了子组件上，因为要共享同一个用户信息，所以把用户信息userInfo放在vuex上，然后添加了对应的获取userInfo的action，第一个子组件首先它在onload的时候会先判断state上有没有用户信息，如果没有的话执行getUserInfo去获取，getUserInfo里面会使用axios调用接口，然后把axios返回的promise放到state的userInfo上，然后返回这个promise，子组件的其他逻辑就会await这个promise，其他的子组件onload的时候会发现state上有用户信息，并且是一个promise，就回去await这个promise，后面再执行其他的逻辑
### 问题
后来发现，发起请求的子组件，await后面的代码反而是最后一个执行的，理论上最先发起的子组件的代码应该是第一个被添加到微任务队列里面才对，一开始怀疑是子组件的问题，把第一个子组件屏蔽后，发现还是一样，现在换成了第二个组件先发起请求，可是还是最后才执行，后来打debugger的时候发现原来是vuex把dispatch的返回值封装了一层promise
### 解决
为了解决这个同步问题，我把state上面的promise也封装了一层promise，发现还是会有问题，而且在后续测试过程中，我发现不仅是延后，而且还是延后了两个then时序，其他子组件的逻辑都跑两轮了，第一个子组件才开始跑
### 定位
后面继续测试的时候我发现vuex的dispatch封装的使用的new Promise，我自己封装的使用的Promise.resolve()，这两个api虽然都会返回一个promise，但是实际上会有差别。继续查文章的时候，发现stackoverflow上有一个问题是跟这个相关的，其中提到了一个叫promiseResolveThenableJob的微任务，结合tc39文档和一些tc39的文档解析，发现使用Promise.resolve传入一个thenable是会直接返回这个thenable，new Promise然后resolve一个thenable的话，新的promise会旧的promise做一个状态跟随，延后一个微任务，同时这个状态跟随会使用promiseResolveThenableJob这个微任务包裹，所以这就延后了两个微任务
### 额外发现
在研究这个问题的时候，发现了async还有一个特性，await后面运行的代码，会对await右边的表达式做状态跟随，在chrome73的版本下，状态跟随大概是使用new Promise来实现的，在chrome 73以后，使用的Promise.resolve来实现的，其实是nodejs8的时候有一个激进优化，不符合规范，不过后来v8的开发人员发现这个优化性能很好，所以就同步更改了，并且也同时改了ecma的规范
### 结果
最终我决定还是把子组件的等待用户信息的逻辑放到上一层组件上，由上一层组件获取了再传下来，来防止现在或者未来迭代的时候，可能会因为这些细节问题导致的bug



## 项目难点2
在做微前端的时候，整个项目的难点在于如何落地。落地最主要的就是如何减少开发人员接入成本。

qiankun虽然说侵入性比较弱，可是还有一定的改造代码量，所以我前期做了不少准备

### 前期准备
#### 接入改动
因为生命周期一般只用到mount和unmount，所以我封装了一个库，里面只对外暴露一个register方法，接入方接入的时候只需要把原来挂载app的逻辑作为函数参数传进去，然后返回一个卸载方法即可，减轻了接入方开发人员的心智成本

#### 用户信息
使用微前端运行时，用户数据、token、菜单等信息会在主应用传入，当子应用单独运行时，封装的库会从url上读取和发起请求获取菜单数据，然后在register中传入，子应用可以直接使用，不需要关心当前是否是微前端环境。

#### 校验权限
使用http-catcher封装了一个库，拦截全局的xhr请求，自动带上token，并且当token过期的时候会拦截返回，使用refreshToken刷新后重试请求再返回到业务代码

### 落地过程
实现上，先手动改造了两个小的系统，并且边接入边完善提供的插件和库等，同时输出了接入文档和注意事项，接入人员可以在一个小时内完成修改，上线后保留原来子应用单独运行和接入微前端运行两个入口，最后小范围灰度测试

### 后期工作
#### 本地开发
而且还使用chrome拓展写了一个插件，用户可以直接通过插件打开开发测试环境的应用进行调试，不需要从sso进入，并且能储存多个账号密码方便切换，插件还可以修改主应用拉取子应用的地址，开发人员可以使用本地打包的子应用在主应用上进行调试

#### 新子应用
针对新开发子应用，还提供脚手架进行快速搭建，提供了完善的模版，用户拉取后可以直接专注业务代码，不需要管理用户登录菜单等信息

添加了子应用配置页面，子应用的返回地址动态配置，新增子应用不需要主应用发版

#### 改进点
1. 主应用和子应用没有抽离公共依赖，虽然这个qiankun官方不提倡，可是按照实际情况，抽离利大于弊
2. 未来可以使用配置来实现灰度
