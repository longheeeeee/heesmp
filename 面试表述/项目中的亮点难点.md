# 1. 码良：
- 技术上，搭建系统的核心是动态组件，递归组件，DSL结构字段设计(Domain Specific Language)三大部分，因为码良系统是开源框架，这些都是框架已经实现的，我们没有做太多的改动，但是也学到了很多。
- 整个系统的工作分成三块，配置化，可视化交互，业务能力，我们主要是针对实际场景对后两块做改动。
主要的工作有：
1. 接入统一登录权限，实现权限角色配置化
2. 界面交互优化，让运营人员能自己解决大部分需求
3. 规范业务组件开发

## 1.1 接入统一登录权限
码良系统自带了登录系统，系统只有管理员用户两种角色，并且是按照业务线进行划分，公司的统一登录是用户加角色，技术上没有业务线的划分，要打通两边的权限，我们在码良上设定了每个业务线下都有三种角色，开发，运营和管理员，用户在登录的时候会带上统一登录的token，根据token调用登录接口，接口查出用户信息后在码良上创建一个新的用户，并且更新对应的权限，再次登录会查找用户已有权限，把新的权限的业务线id和最高权限生成哈希表，遍历旧的权限，把新增、删除、更新的角色权限推进队列，最后统一修改。

## 1.2 界面交互优化
- 系统的使用者主要分成运营人员和业务线开发人员，开发人员进行组件的调试和新页面的开发，运营人员在已有页面的基础上进行复制、修改和发布，因为双方的侧重点不一样，所以需要进行区分。
- 因为码良这个系统设计上偏重于技术人员快速搭建页面，其中有着相当高的自由度，事件的触发、数据的流向都可以使用js脚本来编写，样式修改使用css设置、位置移动需要考虑margin还是top，都需要相关知识，所以对于运营人员来说门槛太高，他们对于页面的修改不需要太复杂，我们可以把能遇见的修改都放在组件里面作为参数暴露出去
- 通过和产品运营人员的沟通和对其他系统的参考，我们把常用的事件和数据使用事件中心和vuex状态管理内置到码良系统上，屏蔽了很多需要技术门槛的功能，并且同使用人员进行了宣发，紧跟反馈，确认迭代方向

## 1.3 规范业务组件开发
- 对于开发人员而言，我们定下了一些规范和默认配置，比如封装了弹窗、http请求方法和各业务线的地址，内置了一些ui组件和常用的库，对于数据共享和事件的触发做了一些规定，并且做了模板，开发人员通过脚手架拉取模版后就能直接开发。
- 根据目前的情况做了一些通用组件，简单的比如轮播、图片、按钮等，复杂的有微信授权，支付等。
- 优化组件联调，通过配置替换掉某个组件的地址，改成开发人员本地地址，实现联调
- 配置代码babel转换，对于一些在平台上直接编辑的js代码，在发布前使用babel进行一层转换，适配es5

## 1.4 码良页面优化：
### 1. 针对码良特性做的优化：
  1. 组件合并，封装js包，减少请求，页面配置放在html上
  2. 增加组件版本合并工具，减少组件版本差异，减少冗余代码
### 2. 针对通用页面做的优化：
  1. 优化埋点，埋点转化成简单请求，延后不必要的埋点，首屏不发送埋点
  2. 图片懒加载，优化图片体积，因为CDN使用的是http2协议，所以不需要新增多个域名，压缩图片。尽量使用jpeg而不是带有a层的png。尝试使用webp格式，可以使用picture进行优雅降级
  3. 整理流程，延后没必要的SDK的加载
  4. 优化组件，头像组件图片上云，vue做external，地址数据上云
  5. 添加各个域名的prefetch，提前创建http连接
### 3. 海外专项优化
  因为cdn在海外没有服务器，所以海外访问需要耗费大量时间在网络上，所以
  1. 添加了海外CDN加速，所有的静态资源都放在CDN上，包括html和css，因为使用了http2协议，所以不需要考虑统一域名的连接数量问题，可以有效提高并发数量和减少DNS查询时间
  2. 添加一台服务器在香港，使用专线对接深圳源服务器，能缩短链路，减少网络拥堵

## 1.5 关于图片：
### 懒加载实现方式：
  1. 监听scroll，获取所有的img标签，然后遍历计算是否有img标签的位置在bodyScrollTop加上bodyHeight范围内，如果有就把img的_src属性赋值给src属性
  2. 使用intersectionObserver api实现，把所有的img都添加上监听，当api触发的时候代表跟body发生了交叉，然后就去替换掉图片的链接，然后取消监听
### webp兼容实现方式：
  1. 在CDN上添加边缘脚本，当用户的accept-type包含webp格式的时候，返回添加了参数转成webp格式的阿里云图片
  2. 使用picture标签，添加source并且设置格式为`image/webp`，最后img标签写的是jpeg的图片地址，这样子浏览器就可以自动根据兼容性来选择加载的图片

## 1.6 页面生成

## 1.7 动态组件，递归组件，DSL结构字段设计

## 1.8 存在的问题
1. 组件使用了提前编译，无法做公共代码提取，模块复用能力差。模块重复打包存在多实例不共享风险。
2. 目前的移动端适配方案比较恶心。


# 2. 微前端
## 2.1 封装组件，创建cli工具和模板
- 为了减少原有项目接入时候的工作量，在项目传入qiankun的配置装了一层封装，把一些通用的配置整合到项目的钩子函数中，比如主应用用户权限的下发，包括在开发环境子应用单独运行下的用户权限请求和返回处理，子应用修改主应用状态的方法，因为qiankun推荐的方法为了兼容性考虑，使用起来稍显复杂和局限，而我们的项目在技术栈上都差不多，而且需要开放修改的主应用数据不多，所以选择的是封装一系列调用主应用store上的action的方法到子应用上
- 在webpack上做了一层封装，添加了一些通用的配置，比如微前端的publicPath，公用环境变量，组件更新等配置
- 构建cli工具，整理了一些常用项目的模板，比如子应用的模板，组件的模板等。

## 2.2 权限系统
权限系统有五个实体，分别是用户，角色，数据权限，菜单，资源，其中菜单分成普通菜单和组件。
1. 用户拥有多个角色，用户和角色的绑定关系上还有数据权限
2. 每个角色可以绑定多个菜单或者组件
3. 菜单下面可以有多个子菜单或者组件，菜单的根节点是子应用
4. 菜单或者组件下面可以有多个资源，资源即后端API，可以细分到不同的参数

权限系统的使用流程：
1. 用户打开页面的时候会根据用户的角色，返回qiankun所使用的子应用的入口地址和用户的菜单组件权限
2. 主应用拿到菜单后渲染菜单，子应用加载的时候拿到菜单动态添加到路由表上，并且根据菜单下的按钮权限显示按钮
3. 用户调用接口是在网关进行拦截和权限校验，没有权限的会返回403

## 2.3 通过refreshToken自动刷新accessToken
- 公司的项目在微前端接入之前，都是各自业务线维护自己的登录鉴权，并且前端的实现都不统一，有使用session cookie的也有token的，接入微前端的同时也创建了一个用户中心的服务，把公司的用户信息和鉴权服务都统一了，但是对每个子应用都封装新的鉴权和刷新机制工作量太大，所以选择在主应用处添加一个拦截XHR的组件，用于往请求上添加授权头和处理异常请求。
- 请求发出之前会被拦截，添加上accessToken，发出然后存到队列里，请求正常返回后从队列里删除；当请求返回403代表token过期的时候，会设置标志锁住队列，后面再进来的请求推进队列里，然后不允许发出，之前发出的请求也拦截住，直接丢弃，不返回给业务代码，然后使用refreshToken去刷新token，刷新成功了取消标志，重新把队列里的请求使用新的token重新发起请求
- 优点是对目前的代码改动小，利于子应用的接入，子应用不需要关心这部分逻辑

## 2.4 用户本地自定义菜单
用户自定义本地菜单，包括菜单的位置，显隐等信息，参考了vue中的patch的相关思想，正常使用下本地没有自定义菜单缓存，如果用户修改过就会生成一份，当用户再次打开应用的时候会向后端请求一份新的菜单数据，然后进行比对进行本地菜单的更新，因为只允许同层移动，所以只需要对同层节点进行对比，根据旧数组的菜单id生成map，遍历新数组进行比对，需要更新的，新增或者删除的都推进一个数组里，最后遍历这个数组进行统一处理