# 项目难点
在做微前端的时候，整个项目的难点在于如何落地。落地最主要的就是如何减少开发人员接入成本。

qiankun虽然说侵入性比较弱，可是还有一定的改造代码量，所以我前期做了不少准备

### 前期准备
#### 接入改动
因为生命周期一般只用到mount和unmount，所以我封装了一个库，里面只对外暴露一个register方法，接入方接入的时候只需要把原来挂载app的逻辑作为函数参数传进去，然后返回一个卸载方法即可，减轻了接入方开发人员的心智成本

#### 用户信息
使用微前端运行时，用户数据、token、菜单等信息会在主应用传入，当子应用单独运行时，封装的库会从url上读取和发起请求获取菜单数据，然后在register中传入，子应用可以直接使用，不需要关心当前是否是微前端环境。

#### 校验权限
使用http-catcher封装了一个库，拦截全局的xhr请求，自动带上token，并且当token过期的时候会拦截返回，使用refreshToken刷新后重试请求再返回到业务代码

### 落地过程
实现上，先手动改造了两个小的系统，并且边接入边完善提供的插件和库等，同时输出了接入文档和注意事项，接入人员可以在一个小时内完成修改，上线后保留原来子应用单独运行和接入微前端运行两个入口，最后小范围灰度测试

### 后期工作
#### 本地开发
而且还使用chrome拓展写了一个插件，用户可以直接通过插件打开开发测试环境的应用进行调试，不需要从sso进入，并且能储存多个账号密码方便切换，插件还可以修改主应用拉取子应用的地址，开发人员可以使用本地打包的子应用在主应用上进行调试

#### 新子应用
针对新开发子应用，还提供脚手架进行快速搭建，提供了完善的模版，用户拉取后可以直接专注业务代码，不需要管理用户登录菜单等信息

添加了子应用配置页面，子应用的返回地址动态配置，新增子应用不需要主应用发版

#### 改进点
1. 主应用和子应用没有抽离公共依赖，虽然这个qiankun官方不提倡，可是按照实际情况，抽离利大于弊
2. 未来可以使用配置来实现灰度


# 通过refreshToken自动刷新accessToken
- 公司的项目在微前端接入之前，都是各自业务线维护自己的登录鉴权，并且前端的实现都不统一，有使用session cookie的也有token的，接入微前端的同时也创建了一个用户中心的服务，把公司的用户信息和鉴权服务都统一了，但是对每个子应用都封装新的鉴权和刷新机制工作量太大，所以选择在主应用处添加一个拦截XHR的组件，用于往请求上添加授权头和处理异常请求。
- 请求发出之前会被拦截，添加上accessToken，发出然后存到队列里，请求正常返回后从队列里删除；当请求返回403代表token过期的时候，会设置标志锁住队列，后面再进来的请求推进队列里，然后不允许发出，之前发出的请求也拦截住，直接丢弃，不返回给业务代码，然后使用refreshToken去刷新token，刷新成功了取消标志，重新把队列里的请求使用新的token重新发起请求
- 优点是对目前的代码改动小，利于子应用的接入，子应用不需要关心这部分逻辑

# 微前端方案对比
微前端实现方案：
1. iframe
2. web Components
3. 路由分发
4. single-spa
5. qiankun
6. icestark
7. emp

### 1. iframe
1. 浏览器刷新导致iframe url丢失，前进后退按钮无法使用
2. 弹窗无法全局
3. 数据共享麻烦，跨域的情况下要使用postmessage
4. 子应用切换会造成大量资源更换
5. 无法实现seo

### 2. web components
1. 可以以此基础实现微前端，可是兼容性很差

### 3. 路由分发
使用nginx进行路由切换
1. 子应用切换会刷新页面，消耗大量资源以及用户体验很差
2. 共享数据只能使用本地存储

### 4. qiankun

### 5. icestark
1. 体量更轻，没有很强的沙箱机制，主要以内部规范和约束为主

### 6. emp
1. 基于webpack5的模块联邦实现
2. 去中心化，子应用可以再引入子应用
3. 实现模块共享（qiankun在设计理念上不同意这个事情）
4. 没有沙箱

# webpack5的模块联邦
1. 去中心化，不需要一个主应用，应用之间可以互相暴露和加载模块，以实现依赖共享和远程加载，一个应用可以是一个生产者，也可以是一个消费者
2. 消费者需要配置依赖的模块，生产者需要配置暴露出去的模块
3. 打包出来的结果有几个，一个是当前项目的入口文件，一个是entry文件，提供给其他项目依赖当前项目的入口，其他暴露出去的模块单独形成文件
4. 消费者下载依赖的项目entry文件，然后执行项目代码，用户import远程依赖的时候从对应项目entry文件中获取到模块的地址，并且使用jsonp加载，生成一个Promise.all，全部加载完成后再执行用户回调
