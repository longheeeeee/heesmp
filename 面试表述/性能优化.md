# 1. 加载
#### 1. 控制连接数量
因为同域名下tcp连接数量chrome下是6个，所以可以把同域名的首屏请求数量控制在5到6个
1. 对于太少的情况下可以适当增加分包数量，比如做路由懒加载减少首屏包体积，然后把首屏用到的文件可以整合到一起
2. 对于太多的情况下，js来说，webpack中可以使用`maxInitialRequests`配置控制拆包数量，可以把不更新库提到CDN上，对于其他资源来说，可以开多个CDN域名分开加载，或者落地页的图片整合长图，添加图片懒加载减少数量，内嵌图片或者样式文件等
3. 整理业务流程，把不需要首屏加载的包放到空闲再下载
4. 优化埋点，把埋点请求延后发送
#### 2. 减少资源大小
1. 代码压缩，把非首屏的包拆开，实现懒加载
2. 开启资源压缩，如使用gzip
3. 图片体积压缩，可以使用压缩工具压缩图片，控制图片尺寸，可以使用webp格式
#### 3. 优化网络
1. 使用CDN来减少物理距离引起的问题，CDN预热减少回源
2. 可以尝试使用海外专线服务器来转发请求，减少进出口拥堵问题
3. 使用HTTP2优化并发
4. 使用prefetch来加快dns查询

# 2. 渲染
#### 1. 避免阻塞
1. HTMl避免嵌套节点太深
2. CSS避免使用标签选择器，放在头部引入，提早CSSOM树的建立，防止阻塞js
3. js放在文档末尾，可以添加defer和async属性异步加载

defer：异步下载，异步执行，在dom树构建完成后
async：异步下载，立即执行
#### 2. 重排
1. 减少js对DOM和样式的访问和修改，减少js获取dom的大小而触发强制重排
2. 可以把某些频繁改变的做layer提升，实现GPU加速
3. 媒体元素设置宽高，避免渲染的时候改变文档大小

# 3. 交互
1. 大量计算可以交给web worker计算
2. 频繁操作如滚动输入等，做防抖节流

# 4. 性能指标
### 1. FCP(First Contentful Paint)
页面首次有意义绘制，该时间可以认为是白屏时间，加快上面的加载和渲染时间就可以优化这个指标。或者可以使用骨架屏来提供一个比较好的用户体验。
### 2. LCP(Largest Contentful Paint)
页面最大元素绘制，动态变化，比FCP更有意义，渲染骨架屏后再渲染实际内容会更新时间
### 3. TTI（Time to Interactive）
首次可交互时间，计算比较复杂，主要体现用户什么时候可以比较流畅的操作。优化点在延后无必要的SDK初始化，把任务拆分，或者使用web worker计算大任务。
1. 从 FCP 指标后开始计算
2. 持续 5 秒内无长任务（执行时间超过 50 ms）且无两个以上正在进行中的 GET 请求
3. 往前回溯至 5 秒前的最后一个长任务结束的时间
#### 长任务为什么是50ms：
用户交互反馈推荐时间是100ms以内，所以不能有超过50ms的任务卡住线程。
### 4. FID（First Input Delay）
首次输入延迟，记录FCP和TTI之间用户首次与页面交互时的响应延迟。
### 5. TBT（Total Blocking Time）
总阻塞时间，记录了FCP到TTI之间所有长任务减去50ms的额外时间之和。同样也是，延后无必要的SDK初始化，拆分任务等。
### 6. CLS（Cumulative Layout Shift）
累计位移偏移，记录页面突然插入大面积内容的偏移量，把图片或者组件等添加宽高就能避免偏移。
### 6. 三个核心指标
- LCP 页面的速度指标，页面最大元素的渲染时间，而且数据会刷新，更能代表首屏时间
- FID 页面的交互体验指标
- CLS 页面稳定指标
