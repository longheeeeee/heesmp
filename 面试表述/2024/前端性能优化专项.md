整个专项分成了两个部分去实现
1. 前期的指标调研和数据收集
2. 结合前面收集的数据来进行优化

# 收集数据
目的：
1. 确定专项治理的最终指标
2. 提供数据给后续优化
步骤
1. 整理现有的指标
2. 补充可能会用到的指标
3. 对比验证指标的正确性

## 整理现有的指标
公司内部的slardar监控方案已经自带了部分的指标，包括FCP/LCP/MFFCP/MFLCP/TTI/FID等。MFFCP(MicroFrontend)是slardar和garfish框架共同上报的数据
## 加载流程
进入页面-主应用加载-子应用加载-子应用挂载-子应用元数据接口返回-子应用主数据接口返回-渲染完成

- 最终目标是优化页面渲染完成的TTI时间
- 同时也需要添加中间各个节点的埋点，包括子应用下载/挂载时间，路由跳转方式等
## 新增埋点
1. 子应用路由跳转埋点，使用garfish自带的跳转钩子实现，用于区分子应用是第一次挂载还是第二次挂载
2. 子应用加载埋点同时也是garfish提供的挂载钩子函数
3. 考虑过，去检测子应用渲染完成的时间，但是react提供的监听方案不推荐生产使用，所以退而求其次，只计算接口返回时间
4. 主数据请求返回时间（核心）
   - （不可行）添加配置，在统一请求方法中添加逻辑，接口请求的时候会根据是不是第一次发起请求来进行计算。需要用户手动配置，增加心智成本
   - （不可行）根据现有的数据，做数据整合，根据session维度来挖掘指定接口的响应时间。有开发量，并且无法分辨请求是否是初始化请求
   - （采用）在最外层添加HOC，并且在统一请求方法中添加栈进行计算，HOC上添加useEffect来停止接口收集，等待所有接口都返回后即是请求时间。缺点是只能收集第一波请求，但是在大多数场景中适用
## 校验数据准确性
1. 使用人工手动计算，如LCP，FCP等时间
2. 通过performance计算时间
3. 通过useEffect来校验主应用/子应用加载完成时间

# 优化部分
主要是使用火焰图结合之前的埋点数据来进行观测
1. 看串行问题
2. 看单个耗时长的问题
## 主应用优化
### HTML耗时长
拨测测试结果显示有2000ms的平均耗时，火焰图显示主要卡点在网络上，部分case从开始连接到开始接受html数据花了8s
- 跨境网络耗时长，服务器在sg，即使是通过CDN的回源通道，也存在网络出口波动的问题
- 为什么不使用CDN来缓存？
   - 预热不靠谱，生效时间不固定，在修bug的时候无法确保用户能访问最新页面
   - 加上cache-control之后，可能会被运营商劫持
   - 考虑泳道，和子应用配置的问题，目前配置是内联到页面上的
   - 可以使用边缘部署，但是海外没有支持
- 可以尝试使用service worker来缓存
### getInfo
发现有一个串行的请求堵塞了子应用的初始化
- getInfo是获取用户信息，然后确定用户信息有效后再初始化子应用
- 优化手段：切换成并行加载，同时使用接口数据缓存
    - 改动涉及到子应用用户信息获取，子应用在加载完成时如果读取不到用户信息则添加事件订阅来获取用户信息
    - 主应用获取到用户信息后会推送事件，如果用户信息为空或者非法则跳转到登录页
### 首屏资源加载优化
发现入口文件大小在gzip之后也有1MB以上
- 使用webpack的插件来分析，发现
1. 有一个正常情况下用不上的编辑器和一个消息中心的业务组件，把引用的组件和库都改成动态import的写法来拆分
2. 打包了3个arco-design，ui库统一版本，在一些组件上使用external来减少不同版本的包。但是有部分中版本号的包无法统一，风险很大，并且考虑到一开始使用微前端就是打算不统一，加上使用了按需加载，所以包体大小可控，强行统一容易出现问题
### 结果
主应用加载耗时从2s下降到900ms，优化力度55%
整体tti时间从4.2s优化到3.5s，优化力度18%（挑了一个子应用的某个页面）
## 子应用优化
### 接口
没发现有子应用接口串行，但是部分元数据接口可以进行缓存
### 主子应用同步加载
原来的微前端加载流程是，HTML -> Main.js -> 主应用挂载 -> loadApp -> 子应用加载 -> 子应用挂载

现在是把HTML上添加一个小型的garfish的代码，这个代码加载后会马上尝试下载子应用，主应用中的代码执行的时候再去等待preload的数据
### 资源加载优化
部分子应用没有区分首屏代码，导致压缩前包体有20MB
1. 抽离非首屏代码，把可以做异步加载的组件抽离，动态import加载
2. UI框架重复打包了
splitchunk的策略主要是
1. 区分initial和async包
2. 单独打包部分库，把不会经常变化的包单独计算hash，减少js缓存的失效频率
### getTopMenu和getInfo接口阻塞
改成异步判断，数据返回后再进行跳转，同时使用接口缓存
### 业务接口优化
- 拆分首屏接口，或者添加参数，减少不相关数据返回
- 合并多个首屏接口

## 灰度上线
1. 主应用优化：除了当前的qa资源外，还可以去蹭别的qa资源，在其他大版本需求测试的时候部署一份到对应的泳道
2. 子应用上线先在一些简单的，人比较少的子应用进行上线，同时配合进行灰度，稳定后再接入重要的子应用

# 防劣化手段
## 使用prefsee工具
公司内部有一个prefsee工具，可以在流水线上增加卡点，在流水线进行构建的时候，去检测页面的tti，可以进行不同的配置，包括对绝对值和相对值的监控，如果超出则需要手动确认
## 监控报警
对各个接入了方案的子应用都进行报警，包括绝对值和相对值变动，同时在周会上需要同步各个系统的性能数据，对有问题的数据需要排查然后同步原因给大家

# service worker
## 生命周期
1. 注册/更新
2. 安装
3. 激活
### 注册
调用`navigator.serviceWorker.register`，传入sw文件地址进行注册，浏览器会自动下载文件，并且开始监听该sw实例返回的事件
### 安装
下载完成后，浏览器会尝试安装sw，在这个生命周期会有两个任务
1. 设置预缓存的资源，我理解是从硬盘中把缓存文件加载到内存里面
2. 等待所有旧版本sw实例都失活了，才会激活新的实例，可以使用`self.skipWaiting`来跳过等待强行激活
### 激活
安装成功后就会激活
1. 清理旧版本的缓存，确定是否需要删除旧的cache表
2. 使用`self.clients.claim()`来强行接管scope范围内的页面
### 拦截
拦截的重点就是实现一个SWR(stale-while-revalidate)。对HTML请求进行拦截。
1. 先判断是否存在HTML缓存，如果存在则直接返回，并且异步发起新的HTML请求，获取完成后使用HTMLtext里面打包工具生成的版本号判断前后HTML是否是同一个，需要更新的话，再判断是否在时间阈值内，目前是使用1s，如果在的话就直接刷新页面，重新加载HTML
2. 不存在则直接发起HTML请求，返回后记录到缓存中
### 轮询
除了用户正常请求，对于频繁更新的HTML来说，额外增加了轮询作为优化点，每隔10min会自动获取一下HTML，刷新缓存
- 目前前端页面的请求qps大约为8，10min一次的额外请求不会造成压力
### 逃生通道
sw开启后如果出现问题，用户无法手动关闭，而且会一直运行在后台，最差的结果是sw把HTML拦截住了，用户无法访问页面
#### 策略
1. 去掉sw再发版
    1. 代码中去掉sw代码
    2. 添加注销代码调用
2. 使用无痕模式，无痕模式不使用sw
3. 添加接口配置
    1. TCC上配置访问信息，通过用户/部门/子应用等维度进行开关
    2. 使用BFF接口进行包裹，直接返回用户是否可用sw
    3. 配置禁用后，用户第一次访问的还是旧的html
    4. 加载到主应用代码时，会尝试获取配置，并且开启轮询
    5. 判断禁用之后，会注销sw，解除sw对页面的控制，并且根据配置决定是否需要reload页面
    6. 用户再次刷新就可以获取到最新页面
### 错误监控、埋点上报、监控报警
1. 对各个有可能出现执行错误的代码都添加了trycatch，并且确保catch分支不会影响用户使用
2. 保险起见，一旦catch就执行注销，并且把注销代码提升到html内部，跟主应用代码分离，确保在应用代码执行前就能进行sw注销
3. 对正常和异常情况都做埋点，比如正常获取html，从缓存获取，下载html耗时长，页面reload等都进行上报，并且建立监控看板和值班告警群，建立错误处理SOP

# 前端缓存接口方案
- 在接口发起之前添加拦截和判断，把接口的地址、参数、body和用户userid拼接到一起来生成key，根据key来判断是否是同一个接口，第一次直接发起，然后保存到本地，第二次先从本地缓存获取，先返回到业务代码，然后异步发起请求刷新缓存
- 因为数据量比较大，使用localforage来存储数据到indexedDB，因为indexedDB原生用法太难，使用localforage可以减少学习使用成本
- 缺点：有一定滞后性，数据更新后用户需要再次刷新才能获取
    - 安全性：后端接口层面上做了实时权限校验，可以拦截边界情况
    - 用户体验：只在影响到首屏加载的部分元数据，如用户菜单等接口进行缓存
- 结论：平均下降了80%（所有情况，包括缓存和非缓存）

# 衍生问题
1. 如何查询包重复问题？
2. 为什么会出现包重复问题？
3. 如何解决？



