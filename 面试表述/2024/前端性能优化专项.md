整个专项分成了两个部分去实现
1. 前期的指标调研和数据收集
2. 结合前面收集的数据来进行优化

# 收集数据
目的：
1. 确定专项治理的最终指标
2. 提供数据给后续优化
步骤
1. 整理现有的指标
2. 补充可能会用到的指标
3. 对比验证指标的正确性

## 整理现有的指标
公司内部的slardar监控方案已经自带了部分的指标，包括FCP/LCP/MFFCP/MFLCP/TTI/FID等。MFFCP(MicroFrontend)是slardar和garfish框架共同上报的数据
## 加载流程
进入页面-主应用加载-子应用加载-子应用挂载-子应用元数据接口返回-子应用主数据接口返回-渲染完成

- 最终目标是优化页面渲染完成的TTI时间
- 同时也需要添加中间各个节点的埋点，包括子应用下载/挂载时间，路由跳转方式等
## 新增埋点
1. 子应用路由跳转埋点，使用garfish自带的跳转钩子实现，用于区分子应用是第一次挂载还是第二次挂载
2. 子应用加载埋点同时也是garfish提供的挂载钩子函数
3. 考虑过，去检测子应用渲染完成的时间，但是react提供的监听方案不推荐生产使用，所以退而求其次，只计算接口返回时间
4. 主数据请求返回时间（核心）
   - （不可行）添加配置，在统一请求方法中添加逻辑，接口请求的时候会根据是不是第一次发起请求来进行计算。需要用户手动配置，增加心智成本
   - （不可行）根据现有的数据，做数据整合，根据session维度来挖掘指定接口的响应时间。有开发量，并且无法分辨请求是否是初始化请求
   - （采用）在最外层添加HOC，并且在统一请求方法中添加栈进行计算，HOC上添加useEffect来停止接口收集，等待所有接口都返回后即是请求时间。缺点是只能收集第一波请求，但是在大多数场景中适用
## 校验数据准确性
1. 使用人工手动计算，如LCP，FCP等时间
2. 通过performance计算时间
3. 通过useEffect来校验主应用/子应用加载完成时间

# 优化部分
## 主应用优化
### HTML耗时长
拨测测试结果显示有2000ms的平均耗时
- 跨境网络耗时长，服务器在sg，即使是通过CDN的回源通道，也存在网络出口波动的问题
- 为什么不使用CDN来缓存？
   - 预热不靠谱，生效时间不固定，在修bug的时候无法确保用户能访问最新页面
   - 加上cache-control之后，可能会被运营商劫持
   - 考虑泳道，和子应用配置的问题，目前配置是内联到页面上的
   - 可以使用边缘部署，但是海外没有支持
- 可以尝试使用service worker来缓存
### getInfo
getInfo是获取用户信息，然后确定用户信息有效后再初始化子应用
- 优化手段：切换成并行加载，同时使用接口数据缓存
    - 改动涉及到子应用用户信息获取，子应用在加载完成时如果读取不到用户信息则添加事件订阅来获取用户信息
    - 主应用获取到用户信息后会推送事件，如果用户信息为空或者非法则跳转到登录页
### 首屏资源加载优化
1. 异步调用的组件抽离成动态包
2. 打包了3个arco-design，ui库统一版本，在一些组件上使用external来减少不同版本的包
## 子应用优化
### 主子应用同步加载
原来的微前端加载流程是，HTML -> Main.js -> 主应用挂载 -> loadApp -> 子应用加载 -> 子应用挂载
现在是把HTML上添加一个小型的garfish的代码，这个代码加载后会马上尝试下载子应用，主应用中的代码执行的时候再去等待preload的数据
### 资源加载优化
1. 合并相同包
2. 抽离非首屏代码，动态import加载
### getTopMenu和getInfo接口阻塞
改成异步判断，数据返回后再进行跳转，同时使用接口缓存
### 业务接口优化
- 拆分首屏接口，或者添加参数，减少不相关数据返回
- 合并多个首屏接口

# service worker
## 生命周期
1. 注册/更新
2. 安装
3. 激活
### 注册
调用`navigator.serviceWorker.register`，传入sw文件地址进行注册，浏览器会自动下载文件，并且开始监听该sw实例返回的事件
### 安装
下载完成后，浏览器会尝试安装sw，在这个生命周期会有两个任务
1. 设置预缓存的资源，我理解是从硬盘中把缓存文件加载到内存里面
2. 等待所有旧版本sw实例都失活了，才会激活新的实例，可以使用`self.skipWaiting`来跳过等待强行激活
### 激活
安装成功后就会激活
1. 清理旧版本的缓存，确定是否需要删除旧的cache表
2. 使用`self.clients.claim()`来强行接管scope范围内的页面
### 拦截
拦截的重点就是实现一个SWR(stale-while-revalidate)。对HTML请求进行拦截。
1. 先判断是否存在HTML缓存，如果存在则直接返回，并且异步发起新的HTML请求，获取完成后使用HTMLtext里面打包工具生成的版本号判断前后HTML是否是同一个，需要更新的话，再判断是否在时间阈值内，目前是使用1s，如果在的话就直接刷新页面，重新加载HTML
2. 不存在则直接发起HTML请求，返回后记录到缓存中
### 轮询
除了用户正常请求，对于频繁更新的HTML来说，额外增加了轮询作为优化点，每隔10min会自动获取一下HTML，刷新缓存
- 目前前端页面的请求qps大约为8，10min一次的额外请求不会造成压力
### 逃生通道
sw开启后如果出现问题，用户无法手动关闭，而且会一直运行在后台，最差的结果是sw把HTML拦截住了，用户无法访问页面
#### 策略
1. 去掉sw再发版
    1. 代码中去掉sw代码
    2. 添加注销代码调用
2. 使用无痕模式，无痕模式不使用sw
3. 添加接口配置
    1. TCC上配置访问信息，通过用户/部门/子应用等维度进行开关
    2. 使用BFF接口进行包裹，直接返回用户是否可用sw
    3. 配置禁用后，用户第一次访问的还是旧的html
    4. 加载到主应用代码时，会尝试获取配置，并且开启轮询
    5. 判断禁用之后，会注销sw，解除sw对页面的控制，并且根据配置决定是否需要reload页面
    6. 用户再次刷新就可以获取到最新页面
### 错误监控、埋点上报、监控报警
1. 对各个有可能出现执行错误的代码都添加了trycatch，并且确保catch分支不会影响用户使用
2. 保险起见，一旦catch就执行注销，并且把注销代码提升到html内部，跟主应用代码分离，确保在应用代码执行前就能进行sw注销
3. 对正常和异常情况都做埋点，比如正常获取html，从缓存获取，下载html耗时长，页面reload等都进行上报，并且建立监控看板和值班告警群，建立错误处理SOP

# 前端缓存接口方案
- 在接口发起之前添加拦截和判断，把接口的地址、参数、body和用户userid拼接到一起来生成key，根据key来判断是否是同一个接口，第一次直接发起，然后保存到本地，第二次先从本地缓存获取，先返回到业务代码，然后异步发起请求刷新缓存
- 因为数据量比较大，使用localforage来存储数据到indexedDB，因为indexedDB原生用法太难，使用localforage可以减少学习使用成本
- 缺点：有一定滞后性，数据更新后用户需要再次刷新才能获取
    - 安全性：后端接口层面上做了实时权限校验，可以拦截边界情况
    - 用户体验：只在影响到首屏加载的部分元数据，如用户菜单等接口进行缓存
- 结论：平均下降了80%（所有情况，包括缓存和非缓存）

# 衍生问题
1. 如何查询包重复问题？
2. 为什么会出现包重复问题？
3. 如何解决？



