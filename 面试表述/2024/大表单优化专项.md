# 背景
# 调研
## 表现
一个页面是联动逻辑比较多，一个页面是表单项比较多
## 原因
### 简单调查
1. 初步调查，能看到有很多的重渲染情况，简单操作一个输入框都能引起整个页面大多数地方的重渲染
2. 使用performance来分析，能看到基本上都是beginWork中执行render的耗时，并且有小部分是框架的代码耗时比较久
### 框架原因
看了下框架的代码，我们使用的ui框架是跟antd-design内部的rc-field-form原理类似，分成三层
1. store，用于存储表单数据
2. 使用一个没有UI渲染的controller层作为HOC，获取store上的数据，然后传进表单组件里面
3. controller层外面再使用UI组件进行包裹，来展示校验信息等
### 框架的问题
1. 惊群问题，用户使用setValue的时候，会先更新到store，然后通知所有的controller层进行自检，使用当前节点的路径信息和发生了变化的数据的路径信息进行匹配，来决定是否需要rerender，在表单项非常多的情况下这个问题会变得很严重
2. 用户在修改的时候喜欢修改高层数据，比如修改一些底层的数据，但是会使用高层数据去提交，导致大面积的渲染
3. 功能不足，只有useWatch这个方法暴露了，无法根据条件判断是否需要更新当前组件
## 选型
因为框架导致的问题比较大，同时也调研了公司内外的多个表单组件，感觉都不太适用，所以打算自己重写表单核心层

表单核心实际上跟状态管理是一样的，都是发布订阅模式，多个组件共同需要获取一份数据，然后在数据发生变化的时候进行重渲染。但是又有自己的一些问题
1. 数量大，一个表单下面可能会有几百上千个表单项
2. 考虑到联动，所有表单组件都需要共享同一份数据
### 常见的状态管理库
1. 不可变数据和单项数据流，代表为redux和zustand：跟现在的表单实现是一样的，存在同样的问题
2. 原子化，代表有recoil和jotai：设计为轻量化，使用简单，不太适合大量的表单项
3. 可变数据，使用类似vue的自动依赖收集-派发机制，代表有mobx，valtio：采用，可以存放大量数据，并且可以精准渲染
### 确定方案
最终确定使用现有的库来实现核心数据层，@vue/reactity能够单独使用，并且已经有非常成熟的应用
- 同时需要提供更丰富的api来支持联动
- 为了支持虚拟滚动，还需要把更多的状态存储到表单内部，而不是放在组件层面上
## 方案
### 概览
分成三层
1. FormRoot/FormNode层作为数据层，承担最基础的发布订阅功能
2. hooks层，基于数据层节点来封装，包括读取数据和联动，如useState等
3. 组件层，使用上面两层进行组合，方便用户使用
### 详细方案
1. formRoot是表单根节点，存储整个表单的数据，并且使用ref进行包裹，对数据进行响应式处理
2. formNode是最基础的表单节点，每一个表单项都是一个formNode，节点上保存了value作为节点数据
3. 为了实现store内部的数据流动，FormNode上的value是一个computed，根据节点的路径，从formRoot一层层往下获取，同时提供watchState方法，使用reactiveEffect监听value，在value发生变化的时候触发callback
4. 为了实现store和react的交互，封装了useFormState去监听formNode上的数据，调用watchState方法，在更新的时候判断数据使用forcerender来进行重渲染
5. 为了连接UI组件、store数据和基础组件三部分，封装了fieldWrapper组件，其中分成两个部分
    1. renderComponent对children提供value和劫持onChange时间，沟通基础组件和表单数据
    2. renderDecorator用于渲染表单样式，传入节点数据，渲染出校验信息等其他表单数据，解耦了表单框架和UI框架，使得表单框架可以对接不同的UI框架
6. 在数组的情况下，使用shallowReactive对children进行监听，只在数组顺序和长度发生变化的时候触发重渲染
### 解决了什么痛点
1. 实现了原子表单，因为嵌套表单有很多痛点
    1. 需要把完整的路径一层层往下传递，耦合性太强，现在改成使用父节点的相对路径就好
    2. 表单可以实现部分校验/部分提交，每一个节点都拥有完整的功能
2. 联动优化
    1. 提供了更多的数据监听，在原来的表单实现中，只能通过useWatch来获取数据，然后通过effect来处理联动逻辑，或者使用shouldUpdate来判断，在层级很深的情况下很麻烦，现在提供了watch方法来使用事件订阅，不用导致渲染
3. 跟UI解耦更彻底，原来有部分数据比如校验规则rules要保存在组件上，如果组件还没进行渲染就获取不到，无法校验没有渲染的表单数据
## 不足之处
1. @vue/reactity中触发更新是同步的，合并修改需要在watcher和使用者中间封装一层lazyCallback，丢到异步任务去
2. 暴露出去的value是ref对象，对于使用react习惯的人来说，用户可能会修改这个返回值，导致触发更新
### 改进
1. 自己实现watcher方法，把lazycallback内聚到watcher触发里面
2. 可以使用immer对数据进行包裹

# 表单虚拟滚动
## 背景
同一个页面有50个款，每个款里面会有大概40个表单项，加起来会有2000个表单项，并且会有6w个dom节点
## 指标选择
INP（ Interaction to Next Paint），chrome提供的api，计算的是用户在操作以后到绘制下一帧的时长
## 问题
1. 使用了懒加载来优化首屏载入时长，但是总体的渲染时间就这么长，就算延后了，用户滚动操作还会因为线程满负荷运作导致卡顿
2. 批量填写等操作会导致大批组件更新
3. 滚动卡顿
## 方案
方案分成两个部分
1. 虚拟滚动的实现
2. 表单组件和UI渲染的解耦
### 虚拟滚动实现
调研了市面上不同的虚拟滚动框架，包括更新活跃情况、实现等方面，选择了react-virtuoso这个框架
### 数据和UI解耦
目的有两个
1. 表单在隐藏的时候也可以有完整功能
2. 表单在重新显示的时候可以带有校验状态等其他信息
所以就需要把组件变成一个dummyComponent，内部不保存数据
### 实现
1. 整理组件上所有的useState和useEffect，做数据提升，把所有的状态和逻辑都提升到最顶层，包括放在表单store里面，或者放在redux里面
2. 把表单的校验规则单独抽离出来，以配置的形式提前放进表单数据层

# 优化效果
INP最大值从10s降低到0.3s，减少了90+。页面整体longtask从600+降低到不到200ms
  



