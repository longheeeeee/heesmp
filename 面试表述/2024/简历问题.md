# 整体
## plm的流程是什么
## BFF层的架构是什么
## node优化做了什么？
## 落地优化方案过程中碰到了什么问题
## 防劣化报警的方案是什么
## 常用推荐、通用草稿是如何实现的
## 通用组件如何设计的？设计考虑到什么问题了？
## 前端工程化指的是什么？
## 微前端的通讯是如何实现的？

# 重构
## 几个人一起做？
## 你负责什么方向？
## 工作量是怎么拆分的？
## 过程中如何协调和验证？

# 大表单优化
## 选择reactity的原因是什么？
## 做完之后的表单架构是怎样的？
## 发布订阅模式，订阅方的事件处理逻辑里面依赖的其他数据，如果没有ready怎么处理？
## 表单精准渲染，可以精准到多细的粒度？如何实现的
## 为什么使用INP作为表单优化核心指标？如何收集的？longtask是如何收集的？有了解过其他指标吗？为什么其他指标不行？
## 虚拟表单是如何实现的

# 通用性能优化
## 都有什么指标？全链路监控如何实现？
## 分包的方案是什么？分包如何实现的？webpack组件怎么用？

## 前端缓存接口方案是什么？
- 在接口发起之前添加拦截和判断，把接口的地址、参数、body和用户userid拼接到一起来生成key，根据key来判断是否是同一个接口，第一次直接发起，然后保存到本地，第二次先从本地缓存获取，先返回到业务代码，然后异步发起请求刷新缓存
- 因为数据量比较大，使用localforage来存储数据到indexedDB，因为indexedDB原生用法太难，使用localforage可以减少学习使用成本
- 缺点：有一定滞后性，数据更新后用户需要再次刷新才能获取
    - 安全性：后端接口层面上做了实时权限校验，可以拦截边界情况
    - 用户体验：只在影响到首屏加载的部分元数据，如用户菜单等接口进行缓存
- 结论：平均下降了80%（所有情况，包括缓存和非缓存）

## HTML为什么不能使用CDN？
## service worker如何实现的？
## 逃生机制是什么？为什么需要逃生机制？

# 其他
## 微前端整合之后，碰到过什么问题吗？
## 微前端架构下，团队是如何协作开发的？
## 海外投放优化是做了什么？

