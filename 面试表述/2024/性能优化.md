# 1.明确指标
1. 加载性能，用户能够更快的看到页面，北极星指标为TTI，围栏指标为FCP/LCP等，TTI为页面加载完成后的耗时，简单来说就是用户可以开始进行有效操作的时间
2. 交互体验，用户操作无卡顿，北极星指标为INP。INP为用户在操作后产生的卡顿耗时，只记录50ms以上，能反应用户操作页面的普遍卡顿情况。同时也需要把围栏指标列为LongTask，FID，FID表明了用户在首次加载完成后的操作时间，LongTask则是页面中包括用户操作和系统自己产生的长任务的耗时。
3. 稳定性，页面崩溃/白屏/报错等，北极星指标为页面加载成功率，围栏指标包括资源加载成功率，JS错误率等。
# 2. 明确需要优化的页面
最终目标是优化高频页面，但是为了保证线上页面的稳定性，需要采用渐进式的优化手段，先从中等频率的页面开始优化，再逐步升级
# 3. 收集数据
## TTI
首先是TTI时间，chrome上的TTI，或者是通用埋点框架自带的TTI没有办法确定页面主要数据下载和渲染完成的时间，比如渲染空表格和默认数据请求回来的表格，需要以真实有效数据返回后为准。
所以需要手动进行收集，同时需要注意几个点
1. 渲染流程上需要区分三种情况
    1. 主应用冷启动加子应用冷启，主应用和子应用都会走完加载-挂载流程
    2. 子应用跳转到另外一个冷启的子应用，子应用会触发加载-挂载
    3. 子应用跳转到另外一个加载过的子应用，子应用只会触发挂载动作
2. 如何埋点，因为需要加上主数据返回后进行渲染的耗时，所以需要手动重新埋点，同时因为react提供的渲染完成的profile组件不推荐生产使用，并且手动计时测试过渲染时间占总耗时可以忽略不计，所以直接采用计算接口返回的时间
  1. 代码上最简单的方法就是手动埋点，在代码中主数据返回的接口回调上调用埋点，页面太多，接入成本高，维护成本高，不采用
  2. 使用HOC包裹APP，在页面请求发起的时候去收集，然后在HOC的useEffect执行的时候停止收集，这样子就能拿到页面在渲染完成的第一时间发起的全部请求，等这些请求都返回了，就是TTI时间
## INP
INP收集比较简单，chrome官方提供了工具接入，需要注意的是要在关键操作，比如搜索，提交等按钮上添加id，这样子上报的时候就能获取到操作来源进行识别
## 明确目标
主应用TTI 75分位在2s左右，整体的在4s到12s不等，确定优化目标为40%
# 4. 性能分析
根据之前收集的数据，结合不同的工具对页面的性能进行分析。可以分成几个方向
1. 资源分析，通过webpack插件来进行分析
2. 请求分析，通过network工具、拨测网站进行分析
3. 运行时分析，通过preformamce进行分析


# 5. 落地方向
## 网络
缩短链路，预先加载
1. 避免多余的重定向
2. 开启HTTP2，可以解决并行数量限制
3. 开启CDN，并且需要确定海外和国内的限制
4. 预加载
    1. dns-prefetch可以提前解析域名
    2. preconnect可以预先建立连接
    3. prefetch可以预先下载资源
### 缓存优化
1. 添加http缓存
2. 缓存本地接口
3. 使用service worker缓存html
## 资源
减少包体积
### JS优化
1. 代码压缩
2. 开启gzip，这个需要服务器支持
3. 拆包，分成首屏包和非首屏包
4. 组件/库拆包，提高缓存利用率
5. 异步组件/非首屏代码可以动态引入
6. 组件库使用按需加载，配合treeshaking减少包体积
7. 组件/库添加externals，减少重复包版本
### CSS优化
1. 代码压缩
2. 删除无用的CSS样式，比如tailwind
### 图片优化
1. 压缩图片体积，图床一般自带压缩
2. 选择合适的图片格式，矢量图使用svg，位图使用webp
3. 减少图片数量，使用css或者iconfont代替icon
4. 加载优化，包括懒加载、预加载、渐进式加载
## 解析
### 合理的资源位置
1. css放在顶部，提前下载和同步跟DOM解析
2. js放在底部，延后下载，防止阻塞DOM和CSSOM构建
### 脚本异步加载
1. 添加defer属性，异步下载并且不阻塞解析，在DOM生成完成后再执行
2. async，异步下载，但是下载完成后会马上执行
### 渲染
1. CSS避免使用通配符
2. 减少选择器嵌套，最好不超过3层
3. 减少在代码中频繁调用getBoundingClientRect等需要实时获取宽高的方法，会导致重排
4. 频繁变化的元素提升合成层，开启硬件加速，减少重绘消耗，不要在低层级元素上开启，会导致层爆炸
5. 减少页面DOM数量，使用虚拟滚动
### 运行时
分析请求时序图，优化数量和大小
1. 首屏接口拆分，暂时用不到的数据延后获取
2. 删除接口中的无用字段
3. 大聚合接口可以划分成小接口
4. 非必要串行的业务接口改成并行，或者合并接口

react重渲染
1. 合理规划组件，拆分大组件，频繁变化的组件单独抽离
2. 频繁变化的数据不在高层级组件上监听，下发到业务组件上自己监听，防止高层组件重渲染导致下面全重渲染
3. 依赖倒置原则，区分业务组件和基础组件，业务组件处理完数据后传给基础组件，减少基础组件的渲染
4. 合理使用memo，useMemo，useCallback等hook
5. 减少context使用，会导致大面积渲染

## 针对微前端
### 流式渲染
react18基于concurrentMode推出了流式渲染功能， 
### 子应用资源预加载
把传统的子应用资源并行跟主应用一同加载，需要先识别子应用信息，再执行主应用代码
### 

# 5. 实际落地
## 5.1 串行接口改并行或者异步
原本的加载流程时获取到用户信息后，再根据用户信息是否可以访问当前应用，再加载子应用。现在修改成用户信息异步获取，先加载子应用，用户信息获取后如果非法再跳转到登录页，同时后端接口也保证了接口有权限校验，防止了用户越过权限
- 改动同时也影响到了所有的子应用，子应用里面使用到用户信息的需要修改到异步
## 5.2 包体积大小
1. 首屏加载单独分包
2. 把非首屏使用的代码模块都改成异步加载，单独拆包
3. 统一UI框架版本，组件里面使用external来加载应用UI代码
## 5.3 主子引用同步加载
原来的加载流程是先加载主应用，主应用再去注册子应用，然后再下载和加载。现在是在html前面先加载一个删减版本的微前端代码，把子应用下载提前到主应用代码执行前，主应用注册子应用的时候就可以共享这个进度
## 5.4 元数据接口缓存
- 应用内有很多比如用户信息，菜单等元数据接口，改动频率不高的，可以进行缓存
- 在接口发起前添加拦截和判断，把接口的地址、参数、body和userid拼接到一起来生成key，先返回缓存到业务代码，再异步发起刷新
- 因为数据量比较大，所以使用了localforage来把数据保存到indexedDB，减少学习成本
- 缺点是会有滞后性，用户需要刷新才能获取最新数据，同时安全性也需要考虑，目前是后端接口做了用户权限的实时判断，可以拦截边界情况
## 5.5 service worker缓存html
理论上html可以放在cdn上做缓存，但是有几个问题
1. 预热不靠谱，如果是事故/回退这种需要实时更新的可能会出现问题
2. cache-control可能会被运营商劫持
3. 泳道和子应用配置内连在了html上，无法缓存
开启service worker来对html进行缓存，采用的是异步请求的机制，用户第二次获取页面会先使用缓存，再异步发请求刷新缓存。同时也做了一部分优化
- 轮询，防止用户长时间不刷新页面，我们采用了10min一次请求来刷新缓存
- 逃生通道，因为sw一旦加载，如果出现问题，用户无法手动关闭，所以需要设计逃生通道
    1. 无痕模式不会加载sw
    2. 去除sw相关代码，手动添加卸载代码，进行发版
    3. 添加了接口配置，根据用户/部门/子应用等维度进行配置，使用sw前会先请求配置，同时开启轮询刷新配置，如果配置更新成关闭则马上卸载
我们在sw生命周期和各个操作上都添加了埋点，一个是为了收集使用情况，一个是可以做监控报警，我们对各种异常状态都添加了报警，建立看板和值班报警群，同时也建立了异常处理SOP
 
# 6. 防劣化
对于我们之前收集到的整体指标数据都需要建立看板和异常报警机制，并且通过公司的工具，我们在流水线上添加了卡点，在上线前可以主动监测指标是否劣化，从而阻塞卡点。

并且在周会上会同步每个系统的现状，对于特殊情况需要排查和同步




# 参考文章
- [CSS 选择器时一定要从右往左解析？](https://www.zhihu.com/question/20185756?rf=21051936)





