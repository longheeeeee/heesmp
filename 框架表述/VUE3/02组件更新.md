# 更新流程
副作用函数componentEffect在更新的时候被调用是什么流程：（对应renderWatcher重新渲染流程）

1. 更新组件vnode：判断组件实例中是否有新的组件vnode，有则更新，没有则沿用
2. 渲染新的组件子树vnode
3. 根据新旧vnode节点进行patch

# patch逻辑：
1. 判断是否是相同的vnode（sameVnode）
2. 不同的直接替换，相同的走diff算法更新

会深度遍历各个vnode元素，并且调用patch

## patch处理组件vnode元素时：
进入patch的processComponent方法，其中调用updateComponent方法进行更新
1. 判断子组件是否需要更新，不需要的话只复制属性，判断依据是对比新旧vnode中的props，children等属性
2. 需要更新的话，调用子组件的副作用函数进行更新

- 在子组件的副作用函数中，就回到了上面更新流程的第一步，更新组件vnode，然后父节点会传入新的vnode作为next，然后更新子组件的vnode数据，包括更改组件实例的vnode指向，更新props和插槽等内容，后面子组件的子树vnode生成会用到更新后的数据

## patch处理普通vnode元素
进入patch的processElement方法，其中更新会调用patchElement方法
1. 更新元素的props
2. 使用patchChildren更新子节点

patchChildren更新子节点会做判断，其中如果新旧都有子元素则做diff算法，其他的会做替换，比如空元素会直接替换，文本节点会删除再替换等

## diff算法：
vue2的流程：
头头-尾尾-头尾-尾头，对比完成后步进
vue3的流程：
1. 头头，对比后更新且步进，再次判断头头
2. 尾尾，对比后更新且步进，再次判断尾尾
3. 对比完成后剩下三种情况：
  1. 对比完成，剩下新节点，添加新节点
  2. 对比完成，剩下旧节点，删除旧节点
  3. 未对比完成

中间未完成的对比流程：
1. 对新序列生成map
2. 正序遍历旧序列，做更新和删除（不移动），并且在遍历的过程中生成newIndexToOldIndexMap，这个是一个数组，存放新序列的元素对应旧序列的位置，会有一个+1的偏移，旧序列中没有的，会变成0
3. 计算最长递增子序列
4. 倒叙遍历新序列，需要新增的就新增，需要移动的就移动，如果在最长子序列中的就跳过，并且最长子序列索引j-1，一直到最长子序列都跳完后（j==-1），后面的就继续新增或则会移动

- 理解：生成最长子序列就是为了把其中最长的不用动的节点挑出来，只移动必须要移动的节点，减少移动次数

## 最长递增子序列算法：
动态规划，算法时间复杂度为O(n^2)，vuejs使用贪心加二分查找，贪心时间是O(n)，二分是O(logn)，总时间复杂度为O(nlogn)

动态规划解法为：
```
dp[i] = max(dp[j]) + 1    (0<=j<i; nums[i]>nums[j])
```
`dp[i]`是前面所有`dp[j]`的最大值，并且`nums[i]`要大于`nums[j`]


# 总结
当一个组件依赖更新时，会调用副作用函数进行重新渲染，过程为更新组件vnode，生成新子树vnode，新旧vnode进行patch

#### patch过程
- 如果是组件的话会判断组件是否需要更新，需要的调用组件的副作用函数
- 如果是普通元素的话，先判断是否新旧都有子元素，是的话diff，不是的话整体替换

#### diff
1. 重复头头对比
2. 重复尾尾对比
3. 剩下中间的，判断是不是只有新或者只有旧
4. 正序遍历旧，更新和删除
5. 生成最长递增子序列
6. 倒序遍历新，做移动和新增，最长递增的就不动
