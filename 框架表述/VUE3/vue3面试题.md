# vue3对比vue2有哪些优化？
优化分成三个方面
1. 源码优化
2. 性能优化
3. 语法优化
## 1. 源码优化：
### 1.1 源码体积优化
使用了`monorepo`来管理源码，代码上做了拆分，模块进行了解藕，阅读成本降低了，并且使用`esm`输出，支持`tree-shaking`，用户可以按需引入模块，删除没有被使用的模块，减少了引入体积
### 1.2 源码类型优化
`2.x`使用的`flow`有很多问题，所以`vue3`使用的是`typescript`来做类型检查，`ts`有更复杂的类型推导，有更好的生态
## 2. 性能优化
### 2.1 数据劫持优化
#### vue2的数据劫持缺点
使用`Object.defineProperty`来实现数据劫持，不能监听到对象和数组的新增删除，并且对于嵌套很深的对象，会把每一层都做响应式处理，浪费性能
### vue3的改进
`vue3`使用`proxy`来实现数据劫持，能监听到数组和对象的新增删除，并且不会把对象的每一层都做监听，在`get`的时候才会去做对应的响应式处理
### 2.2 编译优化
#### 2.2.1 blockTree
`vue2`原来`patch`过程会遍历所有的节点，对于静态的节点会跳过，`vue3`的`patch`过程只会遍历有动态数据的节点
`patch`生成`vnode`的时候，会判断节点后代的类型，如果是一个有动态数据的节点，就会被存放到`dynamicChildren`中，其中部分的节点，如果数据更改的时候会更改节点的子节点的话，比如`v-if`和`v-for`等，这些节点就会被提升成`block`，`block`下面的子节点不会存放在父级的`dynamicChildren`中。这样子，`patch`的时候就只遍历`dynaminChildren`就可以了，其他静态节点不需要遍历
#### 2.2.2 patchFlag
在生成`render function`的时候，会对有动态数据的节点根据不同的类型打上不同的标签，比如只有`props`会更改的，或者是只有`text`会更改的，然后在`patch`的时候就可以根据这个标签只更新部分的数据
#### 2.2.3 静态提升
`render function`生成的时候会把静态的节点从函数中提升到函数外面，使得在调用`render function`重新生成`vnode`进行更新的时候，静态节点不需要重复生成一样的`vnode`，并且数量过多还会进行合并，用空间换时间
### 2.3 diff优化
1. 重复头头对比
2. 重复尾尾对比
3. 剩下中间的，判断是不是只有新或者只有旧
4. 新生map，正序遍历旧，更新和删除
5. 生成最长递增子序列
6. 倒序遍历新，做移动和新增，最长递增的就不动

## 3. 语法优化
使用`composition api`来代替原来的`option api`，相关逻辑的代码可以放到同一个函数中，并且可以优化`mixin`，消除命名冲突和代码来源不清晰的问题