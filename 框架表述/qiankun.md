# 1. import-html-entry
## 1. 为什么是html-entry？
single-spa使用的是js-entry，子应用入口是一个js文件，带来更新困难、无法分包、对原有项目改动大等问题
## 2. 流程
1. 使用fetch来下载HTML（需要支持跨域）
2. 使用正则匹配HTML内容，记录其中的link和script标签并且替换成注释
3. 使用fetch远程加载link文件，下完后变成style标签替换到HTML上
4. 下载script文件，把qiankun传进来的js沙箱proxy作为全局作用域封装成一个执行器
5. 返回html文档和执行器
## 3. 细节点
1. 加载的html会根据content-type做不同的处理
2. 如何获取到入口文件暴露出来的生命周期方法？es中对对象遍历返回的顺序做了规定，对于非数组索引的字段，返回顺序是先后创建的顺序，在入口文件执行前会先遍历window的最后一个字段，然后执行入口文件，入口文件执行后会把生命周期方法挂载到window上，然后对比window的最后一个字段，改变了的话就是返回的生命周期方法

# 2. JS沙箱
## 2.1 为什么需要js沙箱
防止子应用之间的js全局变量污染
## 2.2 单例沙箱
### 简单描述
记录子应用对window的新增修改字段，子应用切换的时候反做一次
### 流程
1. 记录三个map，分别是新增的变量名、修改的变量名和初始值、新增修改变量的最新值
2. 新建一个proxy，set的时候如果是新增的就记录变量名，修改的在第一次修改的时候记录修改的变量名，后续只更新最新值，get的时候直接返回window的值
3. 沙箱失活的时候，把新增的字段删除，把修改的字段改回原值
4. 沙箱激活的时候，把原来的最新值都覆盖一遍
## 2.3 多例沙箱
### 简单描述
新增一个fakeWindow对象，新增修改都在这个fakeWindow上进行而不是在原来的window上
### 大致流程
1. 生成一个fakeWindow对象
2. 返回的proxy setter直接在fakeWindow上进行，getter判断是否在fakeWindow上，否则返回window上的值
## 2.4 降级沙箱
### 简单描述
遍历window然后逐个字段存起来，激活失活的时候做恢复保存

# 3. 样式隔离如何实现
qiankun的样式隔离主要分成两种，一种是严格样式隔离，使用shadow DOM实现，一种是scopedCss，在选择器上做修改
## 1. 严格样式隔离
### 简单描述
使用shadowDOM把子应用包裹，可以使得子应用的css样式文件不会影响到主应用或者其他的子应用
### 流程
1. 使用div.attachShadow创建一个shadowDom节点
2. shadow.innerHtml修改shadowDom的节点
## 2. 使用scopedCss样式隔离
### 简单描述
通过加上前缀到选择器上来实现scopedCss隔离
### 流程
1. 从获取的style文本
2. 把style文件转换成styleSheet样式表
3. 根据不同的样式做处理，普通的样式在第一个选择器前面加上前缀，根选择器会把根元素替换成前缀
4. style文本替换

# 4. render沙箱
### 简单描述
在子应用切换的时候对于加载的代码、元素和挂载的事件做清除和缓存
### 流程
#### 1. 在子应用bootstrap的时候：
1. 劫持appendChild、insertBefore方法，对link、style元素而言，插入到子应用挂载的DOM上，卸载的时候可以一起卸载，对于script而言，添加js沙箱后再执行
2. 劫持后返回free方法，用于在子应用卸载的时候，恢复原来的appendChild和insertBefore方法
3. free方法执行后返回rebuild方法，可以把子应用的样式文件在重新激活时挂载回去，减少请求
#### 2. 在子应用mount的时候：
1. 拦截setInterval、addEventListener方法，记录子应用设置的定时器和挂载的事件
2. 返回free方法，在子应用卸载的时候去除定时器和事件


# 5. 深刻印象
js多例沙箱创建的时候，会把window上不可配置的属性复制一份到fakeWindow上，正常来说fakeWindow上应该是没有属性才对

直接搜索问题没找到，查看各种源码解析也没有发现有人讨论这个问题，因为qiankun是国人写的，去英文网站上结果反而更少了，查询了github的issue，也跟同事讨论了，看了好几天也没有人能知道问题所在，后来在代码的某个地方发现了有注释提了一下，是proxy的兼容问题

在proxy使用上有一个相关规定：
> 如果当前字段不存在于目标对象或者在目标对象上是configurable的，该字段不能被报告成non-configurable

所以用户使用proxy访问window上不可配置的属性的属性描述符时，因为当前字段不在proxy上，所以触发了这个规定，不能把该字段返回成不可配置的；所以需要把不可配置的复制一份到proxyWindow上

# 6. 微前端解决了什么？
微前端的核心价值：技术栈无关，可以使不同的子应用单独部署，减少技术包袱，减轻重构成本。

# 7. 有什么办法实现微前端？
iframe

# 8. 微前端优化
可以共享依赖，虽然违背了微前端的理念，可是对于当前项目而言，收获是相对较大的

# 9. qiankun为什么需要将子应用输出成umd
qiankun架构下的子应用通过 webpack 的 umd 输出格式来做，让父应用在执行子应用的 js 资源时可以通过 eval，将 window 绑定到一个 Proxy 对象上，以此来防止污染全局变量，方便对脚本的 window 相关操作做劫持处理，达到子应用之间的脚本隔离。
- 打包成cjs的话会使用`exports['app-name'] = factory()`
- 打包成umd的话会使用`root['app-name'] = factory()`，所以使用umd可以直接获取子应用暴露出来的生命周期函数
