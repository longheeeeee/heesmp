# 1. HTTP版本区别：

## 1. http0.9
1. 请求信息只有一行，包括唯一的请求方法GET和请求地址
2. 只能传输html文档
3. 没有响应头信息，只有数据

## 2. http1.0
1. 新增了请求头和响应头
2. 添加多种文件格式支持
3. 添加状态码
4. 添加缓存机制expire、last-modified
5. 新增POST、HEAD方法
6. 添加user-agent请求头
7. 每隔请求需要响应返回后才能发送下一个，造成队头阻塞

## 3. http1.1
1. 添加多种缓存机制
2. 添加多种请求方法
3. 新增断点续传能力-range
4. 添加内容协商机制，包括accept、content头信息
5. 支持响应分块，服务器响应包体大小可变，最后通过一个空数据包表示结束
6. 连接复用keep-alive，建立tcp长连接，一个tcp连接可以传输多个http请求
7. 添加host虚拟主机支持
8. 添加管道化机制，请求可以同时发起，不过因为请求没有序号，所以服务器需要按序返回，没有解决队头阻塞；浏览器厂商使用多tcp连接实行并发

## 4. http2
0. http1.1的缺陷：tcp慢启动、队头阻塞
1. 只使用一个tcp连接来减少慢启动成本
2. 多路复用：添加二进制分帧层，请求会根据id分帧，服务器响应也根据请求id分帧，分帧层接收完成后再组合完整请求/响应返回
3. 压缩头部信息：维护两份字典，一份是常见的头部名称或者名称加值的组合，一份是可以动态的添加内容的，常见的可以直接使用对应的index代替，动态在发送一次后会进行同步，再次发送就可以使用编码。
4. 服务器可以主动推送
5. 可以设置优先级

## 5. http3
0. http2的缺陷：tcp队头阻塞、tcp握手延迟
1. udp没有这个问题，udp的问题是不可靠
2. 基于udp实现quic可靠性协议
3. 问题：中间设备udp优化差

# 2. http请求方法：
1. GET
2. POST
3. PUT
4. PATCH
5. DELETE
6. OPTIONS
7. HEAD

## 2.1 GET和POST的区别
1. 语义上，GET是幂等的，安全的（不修改服务器状态），可缓存的；POST是不安全的，不幂等的，不可缓存的，我们应该按照这样子来使用
2. 浏览器实现上，也会做相应的限制，比如非ajax请求中，不允许GET请求带上body，get请求的数据放到url上，post放在body上，get请求可以被缓存，post请求不能等等
3. 事实上，对于ajax请求并没有太多限制，浏览器的实现和部分库都没有完全按照标准来处理，并且后端逻辑也可以不按照语义来实现，比如get请求可以删除某个资源等。
4. 虽然ajax请求相对自由，可是我们仍然应该按照语义来实现通信，比如使用REST来规范前后端通信。

# 3. http请求状态码
1. 100 接收的请求正在处理
2. 200 请求正常处理完毕
3. 300 重定向
4. 400 服务器无法处理请求
5. 500 服务器处理请求出错

# 4. 包体结构
## 1. 请求报文
1. 报文首部，包括请求行和请求头，请求行包括方法、url、http版本
2. 请求报文主体
## 2. 响应报文
1. 报文首部，包括状态行和响应头，状态行包括状态码和http版本
2. 响应体

# 5. http头
按照常见用途分成三种：
1. 内容描述：如content-type、content-length、accept、accept-encoding等
2. 缓存描述：如cache-control、expires等
3. 跨域：access-control-allow-origin、origin等
4. 其他：HOST，refer、cookie等

# 6. http缓存

## 1. 强缓存

### 1. expires
#### 使用头部
1. expires
#### 原理
资源返回时，服务器使用服务器时间标记资源过期的绝对时间
#### 缺点
1. 服务器和客户端时间不同步会出问题
2. 到期前服务器资源修改，客户端无法感知

### 2. cache-control
#### 使用头部
1. cache-control
##### cache-control取值
1. max-age 指定资源可以被缓存的时间
2. no-cache 重新向服务器验证，直接协商缓存
3. no-store 不做强缓存
4. public 资源可以被中间代理缓存
5. private 资源不可以被中间代理缓存
#### 优点
1. 解决了时间不同步造成的问题
2. 多了很多选项

## 2. 协商缓存

### 1. last-modified
#### 使用头部
1. last-modifiled 资源上次被修改时间
2. if-modified-since 比较资源修改时间是否一致
#### 缺点
1. 无法判断一秒内多次修改
2. 资源内容没有发生变化但重写

### 2. e-tag
#### 使用头部
1. etag 资源标志
2. if-match 对比资源etag是否一致
#### 优势
1. 可以识别一秒内多次修改的情况
2. 资源内容没有修改不会返回
#### 劣势
1. 需要消耗资源进行计算，注意大文件
2. 算法可能每台机子不一致

# 其他面试题
## 为什么http1.1同域名并发数chrome下是6个？
1. TCP协议的限制，PC端端口只有65535个，如果不限制连接并发数的话会把端口都耗尽。
2. 有可能会新建线程去做tcp连接，耗费资源
3. 保护服务器，减少服务器半开连接数
4. keep-alive的使用会优化性能，tcp的慢启动会导致新开链接反而不会效率高

## 为什么会有options请求
`options`请求用于校验服务器是否支持一个真实请求的发送，一般在跨域请求的时候，浏览器如果判断这个请求不是简单请求，就会强制发送一个`options`请求到服务器检查该请求是否能被服务器接受。

简单请求是为了判断这个请求是否会对服务器造成副作用，比如`get`请求、`HEAD`和部分限定请求头的`post`请求会被认为是安全的，安全的`post`请求只能携带`accept`、`content-type`等部分请求头，`content-type`只能属于`application/x-www-form-urlencoded`、`mutilpart/form-data`、`text/plain`

`options`请求可以被缓存，服务器返回`access-control-max-age`可以配置缓存时间，不过这个只限定于同一个请求多次发送，不同请求同样会发送`options`

避免options请求可以：
1. 不跨域
2. 修改成简单请求
