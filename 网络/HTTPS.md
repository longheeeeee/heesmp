# 1. HTTP的缺陷
http是明文传输的，会遭受中间人攻击

# 2. TLS加密方法选择
加密方法有对称加密和非对称加密

1. 对称加密加解密速度快，但是如果中间人拿到密钥就能解密
2. 非对称加密加解密速度慢，但是拿不到私钥的就不能加密或解密，用于单向通信
3. 握手过程使用非对称加密传递对称加密的密钥，通信过程使用对称加密

# 3. 握手过程
## TLS1.2 + RSA
1. 客户端生成`clientRandom`、加密套件列表、`tls`版本号到服务器
2. 服务器生成`serverRandom`，确认加密套件，和`CA`证书返回客户端
3. 客户端确认证书，并且获取服务器公钥，生成`pre-master`并且使用公钥加密，返回服务器，并且使用`clientRandom + serverRandom + pre-master`生成对称加密密钥加密客户端信息摘要确认并发送
4. 服务器收到`pre-master`后，生成出对称加密密钥并加密服务器信息摘要确认并且发送
4. 如摘要没问题则双方使用对称加密密钥进行传输，有问题的发起重新握手

## TLS1.2 + ECDHE
0. REA算法如果密钥泄漏，能解密之前的记录
1. 客户端发送加密套件、`tls`版本号、`clientRandom`
2. 服务器选择加密套件，发送`serverParams`、`serverRandom`、`CA`证书
3. 客户端发送`clientParams`、并且因为客户端已经能算出密钥，可以直接发送数据

## TLS1.3 + ECDHE
0. 因为`tls1.3`大幅删减了加密套件数量，所以可以客户端可以直接把各个套件的参数都计算出来，减少确认次数
1. 客户端生成`算法私钥`，计算出`公钥clientParams`，发送`公钥clientParams`、`clientRandom`、加密套件列表、`tls`版本到服务器，保存私钥到本地
2. 服务器确认加密套件，生成`算法私钥`，计算出`公钥serverParams`，发送`公钥serverParams`、`serverRandom`、`CA`证书到客户端，保存私钥到本地
3. 双方使用各自的`私钥 + 对方公钥params`得出`算法密钥S`，再根据`clientRandom + serverRandom + S`算出对话密钥，直接通信，客户端不需要确认服务器选择，省略一次握手
### 为什么要用到两个ramdom？
因为TLS设计者不信任单个随机数的可靠性，而是采用了四个随机数(两个ramdom和双方私钥)来增加随机的程度

## ECDHE算法和RSA算法的改进
前向安全性：
### RSA
客户端->pre-master + 服务器公钥->服务器->服务器使用私钥解密出pre-master->根据pre-master生成secret
RSA算法是服务器使用私钥去解密客户端使用公钥加密的pre-master，而这个密钥是固定的，一旦泄漏，每次的pre-master都能解密，从而计算出来secret
### ECDHE
生成的secret没有服务器私钥的参与，而是每次都生成一个random来生成secret，就算服务器私钥泄漏了，也没有问题，就算random泄漏了，也只能解密单次握手的消息，其他消息不受影响

# 4. 客户端如何确认证书
1. 服务器向CA请求证书，CA确认服务器信息后，生成证书
2. 证书包含服务器和证书信息（明文）、CA把明文使用hash生成摘要然后使用私钥加密得到证书签名
3. 客户端收到后使用跟CA同样的hash算出摘要，然后把签名使用CA公钥解密得到CA摘要，两者对比能得到是否被篡改
- 这里跟RSA的不一样，RSA是公钥加密，私钥解密，证书是私钥加密，公钥解密
### 4.1 为什么不直接加密内容
加解密大文件速度慢，只需要加解密摘要就能确认是否篡改了

# 5. 抓包工具是如何抓取HTTPS请求的？
抓包之前，抓包工具会提供一个根证书让用户的设备信任，然后抓包时，所有的请求都会先转发到抓包工具的端口上，等于抓包工具做了一层代理，当我们跟抓包工具建立https链接的时候，抓包工具返回的证书是之前信任的根证书下面的服务器证书，所以能通过校验，能跟抓包工具建立https连接

https://anchorety.github.io/2021/01/12/TLS-Handshake%E5%8D%8F%E8%AE%AE/
https://juejin.cn/post/6844904100035821575#heading-74
https://mp.weixin.qq.com/s/U9SRLE7jZTB6lUZ6c8gTKg
https://www.cnblogs.com/xiaolincoding/p/14318338.html