1. 项目背景
2. 项目需求
3. 项目工作
4. 项目复盘
5. 项目优化

# 1. 项目背景
### 业务上
1. `oa`、`crm`、`cms`三个系统的账号系统不一致，用户需要分开登录
### 技术上
1. 工程增大，项目启动慢
2. 同一个项目分支增多，管理混乱
3. 重构成本增加，开发人员难以应用新技术

# 2. 项目需求
针对第一个权限系统的统一，需要做的事情有：
1. 账号数据的统一
2. 权限数据的统一
3. 鉴权方法的统一

针对第二个问题，可以使用微前端解决，需要做的事情有：
1. 菜单数据需要统一
2. 各个子应用需要做修改来接入

所以说，最终的需求分成：
1. 账号数据
2. 权限数据，包括菜单
3. 鉴权方法
4. 接入微前端

# 3. 项目工作
## 3.1 账号数据的统一
直接统一三个系统的数据会造成大量的改动，所以最终的解决方法是对三个系统做一层关联，主要使用`oa`的账号。
1. 原有的用户数据，使用`oa`账号的手机号查询其他系统的对应账号并且做关联
2. 新用户注册的时候，先注册`oa`的账号，然后再登录`crm`、`cms`进行额外信息的填写，然后`crm`、`cms`根据用户的`token`请求`oa`的账号密码信息，直接复制到自己的数据库里
3. 当`oa`账号发生改动的时候，同步到`crm`、`cms`系统更新数据库

## 3.2 权限数据的统一
1. `oa`新增角色管理、菜单管理、接口管理三个管理页面，所有系统都是用`oa`的管理页面做配置
2. `crm`和`cms`的菜单数据和角色数据手动复制（或者使用`sql`复制）到`oa`的菜单管理和角色管理
3. 数据权限因为差别太大，没有做迁移

## 3.3 鉴权方式的统一
1. `crm`、`cms`后端接入网关，统一使用网关鉴权，前端带上`token`请求发送请求，网关进行拦截，把`token`发送到用户中心服务，用户中心校验后放行或者返回`403`没权限或则会`402` `token`过期
2. 子应用菜单接口替换成oa的菜单接口，获取子应用的菜单数据，主应用获取主应用的菜单数据，其中整合了子应用的菜单数据

## 3.4 接入微前端
接入微前端，实际上需要完成下面的事情
1. 改动子应用的代码，暴露生命周期方法
2. 子应用打包方法修改成`umd`
3. 子应用路由添加前缀，并且修改`publicPath`
4. 子应用`nginx`添加跨域头
5. 子应用菜单数据需要整理后复制到微前端菜单数据
6. 编写主应用，包括子应用的挂载，还有用户信息，菜单

对于上面的需求，我们首先尝试修改`oa`来接入微前端，然后在修改`oa`的过程中沉淀出一些工具方法，并且把这些工具方法应用到直播系统上，最后总结出来子应用接入规范再给其他系统接入人员使用
#### 1. 把生命周期方法的暴露逻辑封装成一个组件
##### 目的：
为了减少接入人员对于`qiankun`的多余学习成本，我们封装了一个组件来抹平一些子应用单独运行和接入到微前端运行的差异
##### 实现：
1. 把生命周期方法的暴露逻辑封装成一个组件，然后暴露一些默认的生命周期方法给`qiankun`使用，子应用使用另外暴露的一个`register`方法来接入
2. `register`方法接收一个方法，这个方法传入一个`prop`的参数，`props`传入了主应用传递给子应用的信息，包括子应用当前的一些应用信息，还有主应用传递给子应用的用户信息，菜单按钮权限，主应用暴露给子应用的数据和修改方法等
3. 子应用在这个方法进行初始化，包括`new Vue`和初始化一些比如路由权限等数据，最后返回一个`destory`的方法来卸载
4. 在子应用单独执行的时候，组件会判断当前环境不在微前端环境内，所以主动调用`register`方法，并且单独获取用户信息、权限信息等，包装成`props`返回给子应用

#### 2. 封装了一个刷新token的插件
##### 目的：
因为子应用原本使用的`token`跟`oa`的`token`不一样，也没有刷新机制，如果每个子应用都进行更改的话太麻烦，也不利于后面子应用的接入，所以我决定在主应用的项目里面对全局的`http`请求做拦截，添加一层`token`校验，来减少对子应用的侵入性
##### 原理：
- 组件使用了`ajsx-hook`这个开源库，原理大概是重写了`XmlHttpRequest`，在初始化的时候可以传入一些和`XHR`里面重名的方法，然后在使用`XHR`发起请求的时候和请求返回触发回调的时候，会先查询有没有传入拦截的方法，比如`open`、`onReadyStateChange`等，先执行拦截方法再执行原生方法
##### 实现：
- 主要功能是两个部分，一个是添加请求头，一个是自动刷新`token`
- 实现原理是，组件内部维护了一个队列，然后在发起请求的时候，会把请求放到队列里面，然后判断请求有没有带上`token`，没有的话加上，然后请求返回的时候把队列里面对应的请求删掉。然后当请求返回`302`的时候，把队列锁住，新进来的请求不允许发出，同时发起请求刷新`token`，刷新完成后，替换掉队列里面请求的`token`，打开队列锁重新发送请求
##### 优缺点：
- 优点是减少接入人员的接入成本，对子应用没有侵入性，缺点是如果出了`bug`排查起来会比较麻烦

#### 3. 写了一个`chrome`插件帮助开发
##### 目的：
为了方便子应用开发人员后续的开发和调试，开发了一个`chrome`插件来提供快捷登录和调试的功能
##### 功能：
1. 因为开发人员需要经常登录统一平台再跳转，特别是要经常多环境（开发测试），多账号，多目标页面（本地、线上）进行跳转，所以添加了一个功能快速登录和跳转，根据环境来保存用户的账号密码和目标页面，并且支持保存`token`，这样子就不需要来回跳转了
2. 因为子应用只在本地运行，所以如果想要在开发测试环境调试一些应用间传递消息的功能就不好处理了，所以也提供了在开发测试环境下主应用拉取本地子应用地址进行调试的功能。主要实现原理是插件先获取到子应用列表，然后用户可以手动修改应用列表里面的地址，然后保存到`localStorage`，主应用在拉取列表之前会优先使用`localStorage`里面的列表

#### 4. 迁移子应用菜单权限到主应用菜单
##### 需求：
因为子应用菜单跟主应用菜单并不是一一对应，所以需要根据产品文档来迁移子应用的菜单，并且迁移完菜单后还需要关联原来菜单的角色和接口关系
##### 实现：
1. 产品需要整理旧菜单和新菜单的关系
2. 使用`nodejs`脚本来生成`sql`文件，其中需要生成的逻辑有：
    1. 数据备份
    2. 更新`oa`和直播系统的所有菜单，添加上`/oa`或者`/live-admin`前缀
    3. 生成并插入一级菜单
    4. 插入非一级菜单，根据上一步生成的一级菜单，根据菜单名称查`pid`
    5. 查出旧菜单对应的所有角色，生成跟新菜单的对应关系
    6. 查处旧菜单对应的所有接口，生成跟新菜单的对应关系

#### 5. 开发脚手架和沉淀模版
##### 模版
`oa`和直播接入完成后，我们沉淀出来一个子应用的接入模板，模板中做了下面的一些预设：
1. 做好了微前端的对接工作
2. 用户数据存放在了`vuex`中，直接可以使用
3. 菜单权限和按钮权限都放在了`vuex`上，按钮权限封装了方法来进行鉴权
4. 针对公司里面两套后端的`DTO`都做了`axios`的封装，需要的时候直接生成实例就能用
5. 封装了一些列表页和表单页的`mixin`
6. 自带了一些例子，`copy`后进行修改即可
##### 脚手架
脚手架的功能比较简单，主要就是在`git`上可以拉取模板代码，并且可以根据用户的输入修改项目的一些默认配置

**主要的原理是：**
1. 使用`commander.js`注册命令，并且根据用户的命令执行对应的`js`代码，其中注册了`init`和`create`方法
2. 使用`axios`拉取模板项目列表，列表存放在`git`上，其中有子应用模板、组件模板等
3. 使用`Inquirer.js`来提供问题，供用户选择模板
4. 根据用户选择的模板，使用`download-git-repo`来拉取对应的项目文件
5. 使用`ejs`和用户提供的选项，对项目模板进行修改
6. 最后输出到用户的目录中

#### 6. 添加应用管理页面
子应用的配置如果放在主应用的话，新增修改非常麻烦，所以把应用配置放到后端配置
##### 配置
1. 应用名称
2. 应用入口文件地址
3. 应用前缀

##### 改进
这里预留了版本的选项，后续可以根据配置来返回不同的子应用入口地址来实现灰度

#### 7. 子应用接入规范
##### `webpack`的调整
1. `webpack`调整，需要把子应用输出的格式调整成`umd`格式
2. 子应用的`publicPath`做修改，一个是直接指定，一个是使用`qiankun`提供的变量
3. `devServer`添加`ACAO`头部，防止本地调试的时候主应用加载子应用报跨域错误

##### 子应用代码的调整
1. 子应用引用`micro-app`库，然后读取`register`提供的用户信息，如菜单权限等
2. 子应用的所有路由添加对应的前缀

##### 子应用部署的调整
1. 子应用`nginx`添加`ACAO`头部和`ACAC`头允许携带`cookie`信息

##### 应用配置
1. 应用配置添加应用和版本
2. 添加子应用菜单

# 4. 项目复盘
1. `crm`和`cms`的菜单数据分成多次进行修改，根据产品文档，每次迁移其中一部分的菜单，然后再让部分人进行体验
2. `crm`和`cms`的数据权限太复杂，没有办法一次性迁移完成
3. 子应用的菜单数据迁移的时候需要根据每一个菜单的路由和名称查找，不一定每一个路由都是完整的复制过去，可能同一个父级的二级菜单会被合并到不同的一级菜单
4. 前后端共用一个`nginx`的`location`的话，注意只对前端资源添加`acao`头，因为可能后端接口在后端服务器上就已经添加了

# 5. 项目优化
1. 子应用都是使用`vue`和`element`，实际上可以把这些`vue`和`element`的依赖抽离出一个公共依赖，可是因为`qiankun`的理念不太赞成这种操作，所以没有官方的工具实现，可以使用`systemjs`来帮助抽离
2. 子应用可以根据版本号进行打包，打包成不同的项目文件，在子应用配置页面可以添加灰度的配置，配置各个版本的权重，不同的人返回不同的子应用入口来实现灰度

# 6. 其他的问题
### 1. 微前端方案对比
微前端实现方案：
1. `iframe`
2. `web Components`
3. 路由分发
4. `single-spa`
5. `qiankun`
6. `icestark`
7. `emp`

##### 1. `iframe`
1. 浏览器刷新导致`iframe` `url`丢失，前进后退按钮无法使用
2. 弹窗无法全局
3. 数据共享麻烦，跨域的情况下要使用`postmessage`
4. 子应用切换会造成大量资源更换
5. 无法实现`seo`

##### 2. `web components`
1. 可以以此基础实现微前端，可是兼容性很差

##### 3. 路由分发
使用`nginx`进行路由切换
1. 子应用切换会刷新页面，消耗大量资源以及用户体验很差
2. 共享数据只能使用本地存储

##### 4. `qiankun`

##### 5. `icestark`
1. 体量更轻，没有很强的沙箱机制，主要以内部规范和约束为主

##### 6. `emp`
1. 基于`webpack5`的模块联邦实现
2. 去中心化，子应用可以再引入子应用
3. 实现模块共享（`qiankun`在设计理念上不同意这个事情）
4. 没有沙箱

### 2. `webpack5`的模块联邦
1. 去中心化，不需要一个主应用，应用之间可以互相暴露和加载模块，以实现依赖共享和远程加载，一个应用可以是一个生产者，也可以是一个消费者
2. 消费者需要配置依赖的模块`remote`，生产者需要配置暴露出去的模块`expose`
3. 打包出来的结果有几个，一个是当前项目的入口文件，一个是`entry`文件，提供给其他项目依赖当前项目的入口，其他暴露出去的模块单独形成文件
4. 消费者下载依赖的项目`entry`文件，然后执行项目代码，用户`import`远程依赖的时候从对应项目`entry`文件中获取到模块的地址，并且使用`jsonp`加载，生成一个`Promise.all`，全部加载完成后再执行用户回调