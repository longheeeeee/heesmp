qiankun虽然说侵入性比较弱，可是还有一定的改造代码量，所以我做了一些工作来减少接入人员的工作量
1. 对接逻辑封装组件
2. 封装自动刷新token组件
3. 开发chrome插件
4. 编写脚手架和整理模版
5. 编写接入文档

权限这块的改动：

需要改动两个地方：
1. 接口资源和新旧菜单的对应关系
2. 角色和新旧菜单的对应关系
产品整理新旧菜单的对应关系，然后写一个nodejs脚本来读取并生成对应的SQL，使用的是
sql分成几块：
1. 数据备份
2. 添加新的公共平台应用节点
3. 更新oa和直播系统的所有菜单，带上/oa前缀
4. 插入一级菜单
5. 插入非一级菜单，因为需要pid，所以要先等一级菜单插入完成，再使用名称来查出对应的pid
6. 为新菜单添加菜单资源映射关系，先查出现有菜单所关联的所有资源，再映射到新菜单上
7. 为新菜单添加菜单角色映射关系，先查出现有菜单所关联的所有角色，再映射到新菜单上


``` sql
insert into `oa_module` (`name`, `system_id`, `parent_id`) select '套餐资源管理',9, id from oa_module where name = '营销管理' and detail = '/'

insert into `oa_role_`
```

# 要解决的问题是什么（背景）？
业务上
1. 两个业务线的系统账号体系不一样，要登录两次
2. 权限系统分开实现，鉴权方式不统一，比如有系统会在前端写死角色id来鉴权
技术上
1. 工程增大，依赖增多导致系统启动慢
2. 功能分支增多引起的版本管理混乱
3. 技术债务增多，系统重构成本变大 ，开发团队难以使用新技术

# 针对这些问题，要做什么（需求）？
1. 打通账号体系，统一权限系统
2. 使用微前端来加载子应用

# 实际操作
## 账号体系
把oa账号和其他系统的账号进行关联，登录的时候使用oa的账号，返回oa的token，其他系统后端接入网关，使用网关鉴权

添加权限管理系统，统一用户角色菜单资源权限的配置管理入口

## 微前端
### 接入工作
使用qiankun来搭建微前端，我们先主动接入了两个系统，然后沉淀出一些工具方法来帮助后面系统的接入：
- 封装了子应用对接的组件，包括生命周期，父子应用数据交流等功能
- 开发了一个自动刷新token的组件
- 使用node写了一个脚本来生成权限数据迁移
- 开发了一个chrome插件帮助快速登录和调试
### 未来接入
针对未来的子应用来说，做了这些工作
- 编写脚手架并且整理出子应用的模板，帮助新应用开发
- 添加应用管理页面，动态配置子应用，主应用不用发版
  



#### oa账号体系和CMS，CRM体系是如何接通的：
oa新用户注册之后，访问cms和crm，cms和crm进行账号注册流程，调用oa系统信息获取用户信息，包括账号密码，生成相关账号，然后oa修改密码的时候会调用cms修改密码接口
#### cms和crm的权限对接
实际上并不是微前端项目期间对接的，是之前的需求，cms和crm的菜单和角色都是手动整理后使用sql复制到oa的系统上，这样子cms和crm就可以实现使用oa权限单独运行


# 权限系统



# 背景
cms和crm两套用户体系，各自维护的是各自的用户表，后面新增了oa用户表，然后把oa账号体系跟cms的和crm的做关联，注册的时候要先注册oa的账号，然后再进入cms注册cms的账号

权限分期迭代：菜单权限和按钮权限是逐步迁移的，之前的按钮权限和现在的按钮权限不一样，有一些是前端写死角色id的，这种情况就需要做统一

问题：cms和crm的菜单权限都已经打通了，可是数据权限因为数据量庞大，没法整理，所以一直没有打通

流程：
oa账号体系打通，添加鉴权

背景、需求、需求分析、实际操作、结果、改进










# 项目难点
在做微前端的时候，整个项目的难点在于如何落地。落地最主要的就是如何减少开发人员接入成本。




### 前期准备
#### 接入改动
因为生命周期一般只用到mount和unmount，所以我封装了一个库，里面只对外暴露一个register方法，接入方接入的时候只需要把原来挂载app的逻辑作为函数参数传进去，然后返回一个卸载方法即可，减轻了接入方开发人员的心智成本

#### 用户信息
使用微前端运行时，用户数据、token、菜单等信息会在主应用传入，当子应用单独运行时，封装的库会从url上读取和发起请求获取菜单数据，然后在register中传入，子应用可以直接使用，不需要关心当前是否是微前端环境。

#### 校验权限
使用http-catcher封装了一个库，拦截全局的xhr请求，自动带上token，并且当token过期的时候会拦截返回，使用refreshToken刷新后重试请求再返回到业务代码

### 落地过程
实现上，先手动改造了两个小的系统，并且边接入边完善提供的插件和库等，同时输出了接入文档和注意事项，接入人员可以在一个小时内完成修改，上线后保留原来子应用单独运行和接入微前端运行两个入口，最后小范围灰度测试

### 后期工作
#### 本地开发
而且还使用chrome拓展写了一个插件，用户可以直接通过插件打开开发测试环境的应用进行调试，不需要从sso进入，并且能储存多个账号密码方便切换，插件还可以修改主应用拉取子应用的地址，开发人员可以使用本地打包的子应用在主应用上进行调试

#### 新子应用
针对新开发子应用，还提供脚手架进行快速搭建，提供了完善的模版，用户拉取后可以直接专注业务代码，不需要管理用户登录菜单等信息

添加了子应用配置页面，子应用的返回地址动态配置，新增子应用不需要主应用发版

#### 改进点
1. 主应用和子应用没有抽离公共依赖，虽然这个qiankun官方不提倡，可是按照实际情况，抽离利大于弊
2. 未来可以使用配置来实现灰度


# 通过refreshToken自动刷新accessToken
## 背景
- 公司的项目在微前端接入之前，都是各自业务线维护自己的登录鉴权，并且前端的实现都不统一，有使用session cookie的也有token的，接入微前端的同时也创建了一个用户中心的服务，把公司的用户信息和鉴权服务都统一了，但是对每个子应用都封装新的鉴权和刷新机制工作量太大，所以选择在主应用处添加一个拦截XHR的组件，用于往请求上添加授权头和处理异常请求。
## 实现
- 请求发出之前会被拦截，添加上accessToken，发出然后存到队列里，请求正常返回后从队列里删除；当请求返回402代表token过期的时候，会设置标志锁住队列，后面再进来的请求推进队列里，然后不允许发出，之前发出的请求也拦截住，直接丢弃，不返回给业务代码，然后使用refreshToken去刷新token，刷新成功了取消标志，重新把队列里的请求使用新的token重新发起请求
## 原理
- 使用的库是ajax-hook，有两版实现，第一版是重写XmlHttpReqeust方法，然后可以传入跟原生xhr事件名称一样的钩子，底层的xhr对应方法触发后会先调用拦截钩子，通过后再把结果返回并执行业务代码定义的钩子
- 第二版做了封装，支持传入多个相同名称的钩子和使用了责任链模式来执行钩子，拦截器中要调用next方法才能进行下一个钩子，这样子就可以在拦截方法上做异步处理，比如重新发起请求
## 优点
- 优点是对目前的代码改动小，利于子应用的接入，子应用不需要关心这部分逻辑，缺点是不太直观，如果发现问题，业务开发可能比较难排查问题

# 微前端方案对比
微前端实现方案：
1. iframe
2. web Components
3. 路由分发
4. single-spa
5. qiankun
6. icestark
7. emp

### 1. iframe
1. 浏览器刷新导致iframe url丢失，前进后退按钮无法使用
2. 弹窗无法全局
3. 数据共享麻烦，跨域的情况下要使用postmessage
4. 子应用切换会造成大量资源更换
5. 无法实现seo

### 2. web components
1. 可以以此基础实现微前端，可是兼容性很差

### 3. 路由分发
使用nginx进行路由切换
1. 子应用切换会刷新页面，消耗大量资源以及用户体验很差
2. 共享数据只能使用本地存储

### 4. qiankun

### 5. icestark
1. 体量更轻，没有很强的沙箱机制，主要以内部规范和约束为主

### 6. emp
1. 基于webpack5的模块联邦实现
2. 去中心化，子应用可以再引入子应用
3. 实现模块共享（qiankun在设计理念上不同意这个事情）
4. 没有沙箱

# webpack5的模块联邦
1. 去中心化，不需要一个主应用，应用之间可以互相暴露和加载模块，以实现依赖共享和远程加载，一个应用可以是一个生产者，也可以是一个消费者
2. 消费者需要配置依赖的模块，生产者需要配置暴露出去的模块
3. 打包出来的结果有几个，一个是当前项目的入口文件，一个是entry文件，提供给其他项目依赖当前项目的入口，其他暴露出去的模块单独形成文件
4. 消费者下载依赖的项目entry文件，然后执行项目代码，用户import远程依赖的时候从对应项目entry文件中获取到模块的地址，并且使用jsonp加载，生成一个Promise.all，全部加载完成后再执行用户回调

