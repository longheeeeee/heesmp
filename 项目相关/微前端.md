# 简单来说
微前端在落地的时候，要减轻接入人员的接入成本，所以做了很多的工作，包括
1. 封装子应用对接的相关逻辑，包括生命周期函数和菜单权限获取等
2. 开发一个自动刷新token的组件
3. 开发了一个chrome插件来帮助登录和调试
4. 使用node来生成sql做数据迁移
5. 编写脚手架并且沉淀出项目模板和组件模板
6. 添加应用管理页面，配置子应用不用主应用发版



# 要解决的问题是什么（背景）？
### 业务上
1. 多个业务线的系统账号体系不一样，要多次登录
2. 权限系统分开实现，鉴权方式不统一，比如有系统会在前端写死角色id来鉴权
### 技术上
1. 工程增大，依赖增多导致系统启动慢
2. 功能分支增多引起的版本管理混乱
3. 技术债务增多，系统重构成本变大 ，开发团队难以使用新技术

# 针对这些问题，要做什么（需求）？
1. 打通账号体系，统一权限系统
2. 使用微前端来加载子应用

# 实际操作
## 账号体系
1. 把oa账号和其他系统的账号做一层关联，旧账号使用手机号进行关联
2. 新账号会先建立oa账号，然后访问其他系统的时候再进行对应系统的注册，因为不同的系统会有一些特定的信息需要填写，比如老师信息，艺名等，所以会在新用户登录之后再请求oa的用户信息接口获取新用户的账号密码再存放到系统的数据库。oa在修改密码或者离职的时候会通知不同的系统
3. 鉴权方面，其他系统后端也统一接入了网关，在网关上进行鉴权
4. 添加权限管理系统，统一用户角色菜单资源接口等配置的管理入口

## 微前端
### 接入工作
使用qiankun来搭建微前端，我们先主动接入了两个系统，然后沉淀出一些工具方法来帮助后面系统的接入：
- 封装了子应用对接的组件，包括生命周期，菜单权限传递等功能
- 开发了一个自动刷新token的组件
- 使用node写了一个脚本来生成权限数据迁移
- 开发了一个chrome插件帮助快速登录和调试
### 未来接入
针对未来的子应用来说，做了这些工作
- 编写脚手架并且整理出子应用的模板，帮助新应用开发
- 添加应用管理页面，动态配置子应用，主应用不用发版
### 优化体验
- 添加自定义菜单功能

#### oa账号体系和CMS，CRM体系是如何接通的：
oa新用户注册之后，访问cms和crm，cms和crm进行账号注册流程，调用oa系统信息获取用户信息，包括账号密码，生成相关账号，然后oa修改密码的时候会调用cms修改密码接口
#### 在微前端之前，cms和crm已经可以使用统一token了
实际上并不是微前端项目期间对接的，是之前的需求，cms和crm的菜单和角色都是手动整理后使用sql复制到oa的系统上，这样子cms和crm就可以实现使用oa权限单独运行
#### 权限分期是什么？
根据产品的想法，子应用原本的菜单和微前端的新菜单并不一一对应，所以原来的角色菜单接口绑定关系都要做迁移，当时是让产品定好了迁移的具体内容，使用nodejs写了一个脚本来生成sql语句。包括更新子应用的路由菜单（因为加上了前缀），添加主应用的菜单和复制子应用的角色菜单接口绑定关系。这个菜单的复制并不需要一次性复制完成，会按照产品的需求，把一些小功能先迁移过去，后续再迁移大功能页面，并且因为数据权限存储的位置和格式跟主应用的有很大差别，所以数据权限也需要排期修改。
#### 改进点
1. 抽离公共依赖
2. 灰度


## 权限这块的改动：
需要改动两个地方：
1. 接口资源和新旧菜单的对应关系
2. 角色和新旧菜单的对应关系
产品整理新旧菜单的对应关系，然后写一个nodejs脚本来读取并生成对应的SQL，使用的是
sql分成几块：
1. 数据备份
2. 添加新的公共平台应用节点
3. 更新oa和直播系统的所有菜单，带上/oa前缀
4. 插入一级菜单
5. 插入非一级菜单，因为需要pid，所以要先等一级菜单插入完成，再使用名称来查出对应的pid
6. 为新菜单添加菜单资源映射关系，先查出现有菜单所关联的所有资源，再映射到新菜单上
7. 为新菜单添加菜单角色映射关系，先查出现有菜单所关联的所有角色，再映射到新菜单上


``` sql
insert into `oa_module` (`name`, `system_id`, `parent_id`) select '套餐资源管理',9, id from oa_module where name = '营销管理' and detail = '/'

insert into `oa_role_`
```












# 通过refreshToken自动刷新accessToken
## 背景
- 公司的项目在微前端接入之前，都是各自业务线维护自己的登录鉴权，并且前端的实现都不统一，有使用session cookie的也有token的，接入微前端的同时也创建了一个用户中心的服务，把公司的用户信息和鉴权服务都统一了，但是对每个子应用都封装新的鉴权和刷新机制工作量太大，所以选择在主应用处添加一个拦截XHR的组件，用于往请求上添加授权头和处理异常请求。
## 实现
- 请求发出之前会被拦截，添加上accessToken，发出然后存到队列里，请求正常返回后从队列里删除；当请求返回402代表token过期的时候，会设置标志锁住队列，后面再进来的请求推进队列里，然后不允许发出，之前发出的请求也拦截住，直接丢弃，不返回给业务代码，然后使用refreshToken去刷新token，刷新成功了取消标志，重新把队列里的请求使用新的token重新发起请求
## 原理
- 使用的库是ajax-hook，有两版实现，第一版是重写XmlHttpReqeust方法，然后可以传入跟原生xhr事件名称一样的钩子，底层的xhr对应方法触发后会先调用拦截钩子，通过后再把结果返回并执行业务代码定义的钩子
- 第二版做了封装，支持传入多个相同名称的钩子和使用了责任链模式来执行钩子，拦截器中要调用next方法才能进行下一个钩子，这样子就可以在拦截方法上做异步处理，比如重新发起请求
## 优点
- 优点是对目前的代码改动小，利于子应用的接入，子应用不需要关心这部分逻辑，缺点是不太直观，如果发现问题，业务开发可能比较难排查问题

# 微前端方案对比
微前端实现方案：
1. iframe
2. web Components
3. 路由分发
4. single-spa
5. qiankun
6. icestark
7. emp

### 1. iframe
1. 浏览器刷新导致iframe url丢失，前进后退按钮无法使用
2. 弹窗无法全局
3. 数据共享麻烦，跨域的情况下要使用postmessage
4. 子应用切换会造成大量资源更换
5. 无法实现seo

### 2. web components
1. 可以以此基础实现微前端，可是兼容性很差

### 3. 路由分发
使用nginx进行路由切换
1. 子应用切换会刷新页面，消耗大量资源以及用户体验很差
2. 共享数据只能使用本地存储

### 4. qiankun

### 5. icestark
1. 体量更轻，没有很强的沙箱机制，主要以内部规范和约束为主

### 6. emp
1. 基于webpack5的模块联邦实现
2. 去中心化，子应用可以再引入子应用
3. 实现模块共享（qiankun在设计理念上不同意这个事情）
4. 没有沙箱

# webpack5的模块联邦
1. 去中心化，不需要一个主应用，应用之间可以互相暴露和加载模块，以实现依赖共享和远程加载，一个应用可以是一个生产者，也可以是一个消费者
2. 消费者需要配置依赖的模块，生产者需要配置暴露出去的模块
3. 打包出来的结果有几个，一个是当前项目的入口文件，一个是entry文件，提供给其他项目依赖当前项目的入口，其他暴露出去的模块单独形成文件
4. 消费者下载依赖的项目entry文件，然后执行项目代码，用户import远程依赖的时候从对应项目entry文件中获取到模块的地址，并且使用jsonp加载，生成一个Promise.all，全部加载完成后再执行用户回调

