# 1. 码良：
码良这个项目是在开源框架上做二次迭代的，项目的核心是动态组件、递归组件、DSL结构设计，但是针对核心技术上没有改动到太多，我们主要的工作有配置化、可视化交互、业务能力开发三个方面。实际上的工作对应的就是
1. 接入统一登录权限
2. 界面交互优化
3. 业务组件开发

## 1.1 接入统一登录权限
- 背景：码良自带了登录系统，可是角色只有两种，并且还会根据业务线进行区分，统一登录的权限没有做业务线的区分
- 讨论：如果直接使用统一登录的角色，对于码良改动比较大，所以我们决定对两个系统做一层关联，并且把码良的角色添加到三个，管理员，开发和运营
- 方案：所以工作分成两部分，一个是登录的时候对角色进行关联和修改，一个是修改原有角色的相关逻辑
- 登录：统一登录跳转过来后会带上统一登录的token，然后发给后端，后端获取到token后会查询用户表，没有的话会创建新用户，然后对用户的权限进行更新，会取用户在各个业务线最高权限的角色进行修改
- 添加角色：码良判断角色使用的是123，然后我们需要根据产品文档来对不同的功能做不同的区分

## 1.2 界面交互优化
- 系统的使用者主要分成运营人员和业务线开发人员，开发人员进行组件的调试和新页面的开发，运营人员在已有页面的基础上进行复制、修改和发布，因为双方的侧重点不一样，所以需要进行区分。
- 因为码良这个系统设计上偏重于技术人员快速搭建页面，其中有着相当高的自由度，事件的触发、数据的流向都可以使用js脚本来编写，样式修改使用css设置、位置移动需要考虑margin还是top，都需要相关知识，所以对于运营人员来说门槛太高，他们对于页面的修改不需要太复杂，我们可以把能遇见的修改都放在组件里面作为参数暴露出去
- 通过和产品运营人员的沟通和对其他系统的参考，我们把常用的事件和数据使用事件中心和vuex状态管理内置到码良系统上，屏蔽了很多需要技术门槛的功能，并且同使用人员进行了宣发，紧跟反馈，确认迭代方向

## 1.3 规范业务组件开发
- 对于开发人员而言，我们定下了一些规范和默认配置，比如封装了弹窗、http请求方法和各业务线的地址，内置了一些ui组件和常用的库，对于数据共享和事件的触发做了一些规定，并且做了模板，开发人员通过脚手架拉取模版后就能直接开发。
- 根据目前的情况做了一些通用组件，简单的比如轮播、图片、按钮等，复杂的有微信授权，支付等。
- 优化组件联调，通过配置替换掉某个组件的地址，改成开发人员本地地址，实现联调
- 配置代码babel转换，对于一些在平台上直接编辑的js代码，在发布前使用babel进行一层转换，适配es5

## 1.4 码良页面优化：
### 1. 针对码良特性做的优化：
  1. 组件合并，封装js包，减少请求，页面配置放在html上
  2. 增加组件版本合并工具，减少组件版本差异，减少冗余代码
### 2. 针对通用页面做的优化：
  1. 优化埋点，埋点转化成简单请求，延后不必要的埋点，首屏不发送埋点
  2. 图片懒加载，优化图片体积，因为CDN使用的是http2协议，所以不需要新增多个域名，压缩图片。尽量使用jpeg而不是带有a层的png。尝试使用webp格式，可以使用picture进行优雅降级
  3. 整理流程，延后没必要的SDK的加载
  4. 优化组件，头像组件十个头像放到本地，其他图片上云，vue做external，地址数据上云
  5. 添加各个域名的prefetch，提前创建http连接
### 3. 海外专项优化
  因为cdn在海外没有服务器，所以海外访问需要耗费大量时间在网络上，所以
  1. 添加了海外CDN加速，所有的静态资源都放在CDN上，包括html和css，因为使用了http2协议，所以不需要考虑统一域名的连接数量问题，可以有效提高并发数量和减少DNS查询时间
  2. 添加一台服务器在香港，使用专线对接深圳源服务器，能缩短链路，减少网络拥堵

## 1.5 关于图片：
### 懒加载实现方式：
  1. 监听scroll，获取所有的img标签，然后遍历计算是否有img标签的位置在bodyScrollTop加上bodyHeight范围内，如果有就把img的_src属性赋值给src属性
  2. 使用intersectionObserver api实现，把所有的img都添加上监听，当api触发的时候代表跟body发生了交叉，然后就去替换掉图片的链接，然后取消监听
### webp兼容实现方式：
  1. 在CDN上添加边缘脚本，当用户的accept-type包含webp格式的时候，返回添加了参数转成webp格式的阿里云图片
  2. 使用picture标签，添加source并且设置格式为`image/webp`，最后img标签写的是jpeg的图片地址，这样子浏览器就可以自动根据兼容性来选择加载的图片

## 1.6 页面生成
- 原本的页面展示过程：
打开页面，带上pagekey，页面加载，根据pagekey获取页面配置，加载页面配置，生成组件树，节点组件异步加载对应的组件，然后等待各个组件代码加载，完成展示
- 问题：
根据page获取页面的时候会阻塞后面过程，后面组件加载会造成大量请求。问题就是两个地方，我们可以把两个地方都简化一下，页面配置可以直接放到html上，组件代码可以打包
- 优化
用户发布页面的时候，服务器首先拉取基础的页面HTML文件，然后遍历页面配置，获得所有的组件地址，并且发起请求获取，获取完成后放到同一个js文件中，最后把页面配置封装一层，使用一个函数放到window上，并且使用script插入到html中，最终生成一个html和一个js文件。

页面打开的时候会加载打包后的组件js文件，js加载后再执行初始化，此时因为页面配置已经在window上了，可以直接生成页面，等到节点组件加载组件的时候，因为组件代码也已经加载完成了，就可以直接在缓存中获取，不需要发请求。这样子就可以节省配置请求和浓缩多个组件请求到一个上。

## 1.7 动态组件，递归组件，DSL结构字段设计
#### DSL结构字段设计：
在系统上通过选择组件并且插入的方式生成页面，最终生成的DSL结构是树状的，每一个节点代表一个组件，结构中描述了以下几大类：
1. 组件基本信息：组件的名称，加载地址，版本等信息
2. 样式信息：每个组件都能通过控件调整或者手写CSS代码生成style描述
3. 组件配置：组件暴露出去的配置在用户进行配置后存在props字段
4. event事件绑定配置：以数组形式存储，每一个元素代表绑定在这个组件上的事件，还有对应事件的回调列表，回调列表中保存着其他组件方法的路径，组件内部使用封装的事件进行触发，事件中心会根据id查找对应组件并且依次触发回调
5. 组件混入：系统支持直接写mixin脚本，可以根据不同的情况添加配置，比如给部分图片添加点击事件，所有的脚本存放在script数组上，在组件生成的时候会进行混入。
#### 递归组件：
页面拿到配置后，会递归配置并且生成组件树，每一个节点都会渲染一个通用的Node组件，然后Node组件内部根据对应节点的组件配置，异步加载组件，然后在子递归组件的同级使用`<component>`渲染配置组件，最终生成的结果像一棵圣诞树，树上每一个分支上都挂着一个配件，实际上是通用Node组件生成的树上每一个节点都挂载自己的组件
#### 动态组件：
Node组件调用加载器加载组件，加载器根据组件地址异步加载到组件代码后根据组件名称进行缓存，然后注册组件，注册组件的时候会获取到传入的script配置，添加代码使执行完的代码放到window上，然后使用babel转译后执行，获取到配置后迭代使用extend进行继承后使用Vue.component挂载


## 1.8 存在的问题
1. 组件使用了提前编译，无法做公共代码提取，模块复用能力差。模块重复打包存在多实例不共享风险。
2. 目前的移动端适配方案比较恶心。

### 1.8.1 适配方案是什么
我们所有的页面都根据375的宽度进行配置，在页面打开的时候，使用window.screen.width获取屏幕逻辑像素宽度，然后除以375获得比例，然后添加meta标签，设置name=vireport，content为width=375，initial-scale、maximum-scale、mininum-scale设置成逻辑像素宽度和375的比例，来实现所有设备上的适配
- 问题：因为是使用缩放强行适配，所以在ipad等宽度比较大的设备或者pc上会很难用，很多地方需要做特殊处理，耗费时间

## 1.9 有没有人提出码良的问题？
#### 开发人员提出的优化点：
1. 组件只能本地调试，无法在页面上进行联调，所以我们添加了一个功能，可以在页面上配置组件的本地地址，在特定的打开方式的时候会读取组件的本地地址。
2. 页面需要在发布之前校验用户的输入是否合理，我们的解决方法是在组件内部添加一个beforePagePublish的钩子函数，页面在发布的时候会遍历所有组件的钩子函数，找出所有的beforePagePublish，然后执行，函数返回一个promise，使用for in加async获取所有错误原因然后提示用户