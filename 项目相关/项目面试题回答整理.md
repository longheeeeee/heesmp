# 项目问题
1. 简单描述码良这个项目做了什么？
2. 接入统一登录权限具体做了什么？
3. 界面交互优化做了什么？
4. 业务组件开发做了什么？
5. 码良有没有做什么优化？
6. 码良的实现难点是什么？
7. 现在有没有还没有解决的问题？
8. 实现过程中有没有开发人员的反馈？

1. 简单描述微前端这个项目做了什么工作？
2. 讲一下权限系统
3. 微前端整个工作流程是什么？
4. 自动刷新token做了什么？原理是什么？
5. 微前端方案对比？
6. webpack5的模块联邦了解吗？
7. 脚手架做了什么工作？
8. 还有没有什么不足？
9. 微前端解决了什么问题？
10. 为什么不使用qiankun自带的父子应用数据传递方案？
11. chrome插件的原理



# 码良

## 1. 简单描述码良这个项目做了什么？
- 背景：项目的背景是公司很多的落地页因为一些政策或者其他原因，频繁提出修改需求，对开发和管理造成很大的困难，所以需要一个平台能让运营人员自己完成一些简单的修改需求
- 工作：平台使用了开源框架码良进行二次开发，对平台核心实现没有做太多改动，主要工作分成三个部分，接入登录权限，界面交互优化，业务组件开发

## 2. 接入登录权限做了什么？
- 背景、讨论、方案、工作
- 背景：码良自带了登录和权限系统，可是角色只有用户和管理员两种，并且会跟业务线区分，我们统一登录这块没有做业务线区分，角色也更多
- 讨论：不能如果直接使用统一登录的角色，对于码良的改动会比较大，所以我们决定对两个系统做一个关联，并且添加角色到三个
- 方案：最终方案分成两个部分：一个是登录的时候对用户做创建和权限的修改，一个是修改新增角色的相关逻辑
- 登录：用户在统一登录后会携带token访问平台，前端带上token请求后端，后端校验token后查找用户表，选择创建用户或者根据用户角色修改已有用户的权限信息，取最高权限的角色，然后维护一个session，后续的接口请求都用统一登录token进行校验
- 角色修改：根据产品文档去做系统的功能模块的校验显示等

## 3. 界面交互优化做了什么？
- 使用者，运营，开发
- 因为平台设计上应该是给开发人员快速搭建页面使用的，所以自由度会很高，同时有很多的技术门槛，对于运营人员不太友好，所以我们的工作就是根据开发和运营做两套界面和功能限制，在保持开发人员可以快速修改页面的同时也保证运营人员可以低成本的使用这个平台
- 运营人员：改动的点比较零碎，包括添加组件分类，添加颜色选择器，限制用户随意拖动页面元素，屏蔽一些代码入口等等，主要是屏蔽一些代码入口防止误触，把一些他们可能需要修改的东西都做成配置项让他们直接选择或者输入
- 开发人员：对于开发人员，主要是做一些要求和规范，比如删除一些功能，减少使用代码配置，设置一些默认代码，比如请求地址等，让他们尽量把逻辑都写在组件里面

## 4. 规范业务组件开发做了什么？
- 第一版，规范，模板，添加功能
- 主要是做第一版页面的开发，并且结合几个业务线的一些通用逻辑封装成通用组件，完善组件库，比如带有压缩和懒加载的图片组件，轮播组件，按钮组件等，还有把一些业务功能抽离出来，比如微信授权，发起支付等功能
- 并且定下了一些规范，比如封装了请求方法，弹窗，内置了一些ui组件，对于数据共享和事件触发做了规定
- 沉淀出来一套模板，里面有一些组件的开发介绍和例子，方便开发人员开发新组件
- 添加了一些功能，比如开发人员可以填写本地组件地址，然后在特殊的页面可以拉取本地组件进行联调

## 5. 码良有没有做什么优化？
- 平台优化，通用优化，网络优化
- 把组件打包成一个js，然后把页面配置内嵌到html上，减少请求，并且在用户发布页面的时候提示用户统一组件版本，防止冗余
- 添加图片懒加载，添加图片web格式
- 优化埋点请求，使用简单请求
- 优化一些组件，比如头像组件只存几个到本地，其他的放到cdn上，地址数据也放到cdn上
- 整理流程，延后一些sdk的加载
- 添加海外CDN，统一域名，减少dns查找次数

## 6. 码良的实现难点是什么？
- 难点分成三个部分，异步组件，嵌套组件，DSL设计
- 异步组件：每一个组件的`name`其实都不一样，因为每一个组件可以有它自己的脚本和配置，所以加载的时候会先根据组件和版本下载组件的原始配置，然后进行缓存，使用`vue.extend`根据原始配置生成一个构造函数，然后调用配置的脚本获取组件的额外配置，再使用原始构造函数`extend`组件配置生成组件构造函数，最后使用`vue.component`挂载渲染
- 嵌套组件：码良里面的组件实际上并没有父子关系的存在，使用的是码良内置组件node这个组件形成的一棵树，组件都在这个node组件的里面，类似于圣诞树上面挂的铃铛，进行交互的时候封装了特殊的方法来获取组件（可能是因为他设计的时候是异步加载组件的，设计成这样子就可以同时加载所有的组件，可是这个设计有很大的性能问题，修改难度比较大）
- DSL设计：DSL分成几大块，组件描述，样式配置，事件配置，参数配置，混入script脚本

## 7. 现在有没有还没有解决的问题？
1. 适配方案比较奇怪，可以改成vm



# 微前端

## 1. 简单描述微前端这个项目做了什么工作？
- 项目主要分成两个部分，一个是权限系统的整合，一个部分是微前端的落地
- 权限系统的整合主要是因为各个业务线的权限和用户数据不一致，导致用户需要分开登录多个系统
- 微前端主要是想解决三个问题，一个是工程增大导致项目启动慢；分支增多，版本管理混乱；系统重构成本上升
- 简单来讲，做了下面的几个工作：
    1. 封装子应用对接相关逻辑
    2. 添加自动刷新token的拦截器
    3. chrome插件帮助登录和调试
    4. 统一权限，添加管理页面和迁移权限
    5. 开发脚手架并且沉淀项目模板和组件模板
    6. 添加应用管理页面 

## 2. 讲一下权限系统
- 设计，配置，鉴权
- 设计上分成五个实体，用户、角色、菜单、按钮、接口
- 配置上，有角色关系、菜单管理、接口管理三个页面
- 鉴权上，用户登录后返回token，使用url传给子应用，然后子应用使用localstorage存起来
- 菜单上，主应用根据token请求用户信息，接口返回菜单树和按钮列表，前端使用菜单树进行菜单渲染，通过按钮列表来决定按钮的显隐，子应用获取到菜单后跟本地的路由表做对比，动态添加路由
- 接口上，所有的接口都会走网关，网关会向用户中心发起token校验，不通过的返回403

## 3. 微前端整个工作流程是什么？
主要分成两个部分，一个是权限的统一，一个是微前端的接入
### 权限系统
1. 把oa的账号和其他系统的根据手机号做关联
2. 创建新用户之后，登录其他系统，其他系统会创建他们自己的账号，会调用oa的接口获取账号密码，oa账号变动会通知其他系统
3. 后端统一接入网关鉴权
4. 添加权限管理页面，统一进行配置
### 接入工作
1. 先主动找了两个项目进行接入，然后在接入过程中沉淀出一些方法和组件来帮助接入
2. 封装了子组件对接的组件，包括生命周期、菜单权限等功能
3. 添加了一个自动刷新token的拦截器
4. 开发了一个chrome插件来帮助登录和联调
### 未来接入
1. 写了一个脚手架，并且沉淀出一套模版来供新子应用使用
2. 添加应用管理页面，动态配置子应用，主应用不需要发版

## 4. 自动刷新token做了什么？原理是什么？
- 使用了一个http的拦截器ajax-hook
- 请求发出之前把请求进行拦截，如果没有加上token的自动加上token，然后把请求放到队列里面
- 在返回的时候再把队列中对应的请求删除
- 如果某一个请求返回了402，就会把队列锁住，再返回的内容就直接丢弃，并且新的请求进行拦截，不允许发出
- 然后发起请求，请求刷新token，刷新成功后，再把队列中的请求重新发出，然后就正常返回到业务代码

## 5. 微前端方案对比？
- iframe
- single-spa
- 飞冰的icestack
- yy的emp
- qiankun

## 6. webpack5的模块联邦了解吗？
- 模块联邦可以通过配置应用的一些依赖remotes和暴露出去的模块exposes，来使得每个应用即可以是模块的生产者，也可以是模块的消费者
- 在打包之后，会生成几个文件，应用的入口文件，应用的entry文件，是应用暴露出去的模块的描述，最后是模块暴露出去的模块会单独打包
- 消费者先下载依赖模块的entry文件，然后执行项目文件，到执行到项目中引用的时候，就根据entry文件找到对应的地址，使用jsonp进行远程下载，模块下载完成后，放到全局缓存中，用户代码再通过webpack_require读取缓存并执行

## 7. 脚手架做了什么工作？
- 主要工作就是可以下载git模版代码到当前目录
- 实现原理：使用了commander.js来注册命令，用户调用命令会执行对应的文件
- 使用inquirer.js来提供问题，通过配置问题列表来提供一些单选多选等选项
- 然后使用axios拉取模板列表，用户选择模板后，
- 使用download-git-repo来拉取模板
- 使用ejs对项目代码进行修改，最后复制到用户的指定目录中

## 8. 还有没有什么不足？
1. 没有做公共依赖抽离，可以使用system.js抽离公共依赖
2. 可以做灰度版本控制

## 9. 微前端解决了什么问题？
1. 项目增大，依赖增多导致项目启动慢
2. 功能分支增多引起的版本管理混乱
3. 项目重构成本不断变大，团队难以尝试新技术

## 10. 为什么不使用qiankun自带的父子应用数据传递方案？
- qiankun的数据传递方案使用的是一个观察者模式，所有应用都观察一个数据对象，当数据发生变化的时候做一些处理
- 使用上比较复杂，增加开发人员心智负担
- 传递的数据需要做一个拷贝，产生数据冗余
- 所以我们使用的是暴露一些主应用store的部分方法，包括查询和修改，子应用可以直接调用

## 11. chrome插件的原理
chrome插件东西比较多，主要是使用到了三个部分
- background.js：权限很高，所有页面共享
- content-script：每个页面都会有一个，可是不能访问js
- popup：点击右上角弹出的小窗
- 功能主要分成两个部分，一个是快速登录，一个是把开发测试环境的子应用替换成本地进行调试
- 主要的入口在popup，请求都在background.js进行，使用postmessage进行交互，使用promise封装了一层
- 用户登录后，组装url，然后发送到content-script来打开新页面
- 用户设置子应用地址后，信息发送到content-script，然后存储到localstorage，并且刷新页面，主应用会先检查localstorage再去接口请求应用数据
