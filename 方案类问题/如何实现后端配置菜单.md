现在的路由配置：前端配置路由的入口文件，然后后端配置这个菜单要不要返回，然后前端再动态添加菜单

如果完全使用后端进行配置的话，有几个问题需要考虑：
- 前端如何打包
- 后端配置什么，后端返回什么
- 前端如何使用后端的配置

1. 针对前端如何打包，首先是webpack如何找到对应的页面？
      - 我们可以使用定制规范的方法，规定所有的页面就放在`pages/xxx/index.vue`，然后我们可以使用webpack的nodejs脚本动态添加input和output来实现路由分包，问题是这样子打包不太能发挥出splitChunk的优势，有一些依赖之类的可能不太好搞，比如两个页面同时使用了一个依赖，这样子依赖只能是打包两份，产生冗余代码
      - 接下来我们应该是已经打包完成了，前端这边上传到服务器，然后到后端进行配置了
2. 后端配置什么？
      - 后端应该是需要配置完整的组件地址，这样子前端才能获取页面组件的文件，问题是这个完整的地址从哪里来？
      - 如果前端服务器是固定的，这样子我们就可以写死前缀，配置的时候只写文件就可以了，可是问题来了，hash值怎么办？
      - 或者可以使用文件名固定，然后只匹配文件名来实现，不过这样子我们每次部署的时候都需要删掉原来的文件。
      - 或者可以使用webpack插件，来生成这一次打包的所有结果，然后打包完成后执行脚本通知后端去更新
      - 这样子前端就能获取到对应的所有配置了
3. 前端获取配置之后怎么办？
      - 因为webpack是使用__webpack_require__来包裹引入文件的，现在因为我们使用不了这个方法，我们只能自己实现
      - vue-router加载一个异步页面的时候，需要传入一个工厂函数来等待异步组件，所以我们需要写一个jsonp发起组件加载并且返回一个promise的工厂函数来代替原来webpack生成的__webpakc_require__方法
      - 获取到地址后，使用promise进行封装，使用jsonp加载文件，然后因为我们打包出来的文件是umd格式的，我们就可以从window上获取这个组件，如果我们不清楚组件名称的话也可以在加载之前对window做记录，利用对象遍历字符串字段顺序固定这个特性来获取最后插入到window上的字段，获取到组件后，使用vue.extend生成组件，然后使用Vue.component挂载，并且resolve这个方法，vue-router就可以做路由跳转了



