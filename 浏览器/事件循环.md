js是一个单线程的语言，在需要执行异步任务时，多线程语言可以将线程挂起，可是js也挂起的话，就会阻塞后面代码的执行，所以js使用了异步队列来存放异步任务，同步任务执行完成之后就会去执行异步任务。

`js`有一个`event loop`机制来执行这个异步任务队列，队列中的任务分成宏任务和微任务，还有一个渲染任务不在队列中，而是在特殊的情况下会执行，当`js`开启一个`loop`的时候
1. 从队列中出队一个宏任务，然后执行，队列中没有宏任务的直接检查微任务
2. 执行过程中有可能产生宏任务和微任务，宏任务添加到队列末端，微任务添加到微任务队列
3. 宏任务执行完成后执行微任务检查点，如果当前微任务队列有任务就执行，一直到微任务队列被清空
4. 尝试渲染，如果浏览器判断当前不需要渲染（比如时间没到），就不需要渲染，如果需要的话就会调用`requestAnimationFrame`，然后执行渲染任务，比如重排重绘等
5. 如果当前loop没有执行宏任务或者微任务或者渲染，意味着当前的loop是空闲状态，执行`requestIdleCallback`
6. 到这里一个loop就完成了，接下来会回到第一步获宏任务

宏任务-微任务-raf-ric

## setTimeout在chrome的执行原理：
定时器线程会维护两个队列，一个是延时任务队列，储存延时任务回调和时间，一个是唤醒任务队列，只有时间
1. 当主线程执行setTimeout的时候，延时任务队列塞进一个延时任务
2. 检查当前唤醒任务队列，如果没有比它的时间更短的，就往唤醒任务队列里添加唤醒任务，然后拿出最小的时间，往系统上添加唤醒任务
3. 系统通知浏览器唤醒的时候，把延时任务队列中的到期和过期的任务推到浏览器事件循环宏任务队列中，执行完成后找到队列中最小的时间，添加唤醒任务，重复这一步

参考文档：https://www.zhihu.com/question/463446982