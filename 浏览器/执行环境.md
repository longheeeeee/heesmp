# 1. 结构
执行环境分成两个部分，堆和栈

# 2. 调用栈结构
调用栈内的一个元素叫做执行上下文，分成四个部分：
1. 变量环境：函数内定义的变量
2. 词法环境：块级作用域定义的变量，以栈形式存储，执行完块级作用域就出栈
3. outer：词法上的上一层代码块，连接作用域链，查找变量的时候会逐层查找outer
4. this：指向当前函数的调用者，没有则指向window

- 如何寻找一个变量：先查当前执行上下文的词法环境，然后查找变量环境，然后再沿着作用域链查找下一个执行上下文，继续词法环境，变量环境这样子查找下去

- 当产生闭包的时候，整个元素会只留下一部分变量供其他地方使用

# 3. v8是怎样构建js执行环境的
1. 编译代码
2. 进调用栈：生成全局执行上下文
3. 变量环境：把所有定义的变量做变量提升，函数在var的后面定义，重名情况下优先级更高
4. 词法环境：碰到代码块中定义变量就往词法环境中新增对应的记录
5. 碰到一个新的函数就新增一个函数执行上下文并且进栈
6. 函数执行完毕后函数对应的执行上下文出栈

# 闭包的定义是什么
> 闭包是支持头等函数的语言中，实现词法绑定的一种技术，如果函数f内定义了函数g，并且函数g内存在自由变量（在函数g外定义但在函数内被引用），那么将产生闭包。
js中，内部函数可以沿着作用域链访问外部函数的变量，如果一个外部函数里面返回了一个内部函数，即使外部函数已经执行完毕了，可是返回的内部函数仍然能访问外部函数的部分变量，这部分变量的集合就是闭包。

# 讲一下作用域
## js中的作用域指的是什么
作用域就是变量的有效范围，在js中，es6之前，作用域有全局作用域和函数作用域，全局作用域指的是在代码顶层这个范围内定义的变量，代码所有地方都能访问，函数作用域就是在函数内部定义的变量，在函数内部能访问，函数外部不能访问。
es6增加了块级作用域，使用大括号包围起来的区域会形成作用域，里面定义的变量外面访问不到。
## js中作用域怎样映射到执行栈上的
当js运行代码的时候会创建全局执行上下文，存放在执行栈中，当执行新的函数的时候就会创建一个新的执行上下文，并且入栈，执行上下文主要分成四个部分，变量环境，词法环境，指向上一层作用域的outer指针和指向调用者的this指针，函数内部使用var定义的变量会存放在变量环境区域，使用let/const定义的变量会存放在词法环境区域，词法环境使用栈进行存储，多层嵌套的块级作用域就会推入多个词法作用域
## js中如何沿着作用域链查找变量
js中变量的查找会使用作用域链查找，首先会从当前作用域一直往外面查找，在执行栈上的体现就是先遍历查找当前词法环境栈，然后查找当前执行上下文的变量环境，然后使用outer指针找到上一层的执行上下文，重复查找词法环境和变量环境

# 预编译：变量是如何查找的以及闭包的形成（更新）
1. 当碰到函数的时候，会先对函数进行预编译
2. 预编译的时候会生成函数的`[[scopes]]`，形式是数组，初始化的`[[scopes]]`里面的元素是当前函数一直往作用域链查找的每一层，包括块级作用域和函数作用域，一直到全局作用域
3. 然后会对函数内部的变量进行检查，并且会递归预编译函数内部的函数
4. 当查找到这个函数使用到了外部的属性，就会沿着`scopes`链，把外部属性对应的作用域`scope`替换成一个只包含引用了的外部属性的`scope`，也就是没有引用到的属性不会被添加到新的`scope`对象中
5. 最后把`scopes`链中完全没有使用到属性的`scope`对象给删掉
6. 这样子函数的`scopes`链里面就只存在被内部引用了的外部变量的，缩减过的作用域链
7. 函数在执行的时候就可以直接沿着`scopes`链进行查找，不需要沿着作用域链一层层往上找了
8. `scope`链里面的每一个元素其实都是一个闭包，如果最后这个函数被返回了，`scope`链就会随着函数被保存下来，`scope`上面的每一个元素就是实际意义上的闭包了，哪些没有被使用到的字段就会在执行上下文中，随着上层函数的执行完毕而被销毁
