1. 判断输入的是网址还是搜索内容，如果是搜索内容则跳转到对应搜索引擎页面
2. 检查内置的https列表（HSTS严格传输安全）如果匹配则307到https协议
3. 浏览器进程把请求发送到网络进程，网络进程判断本地缓存，如果有缓存则使用
4. 判断网址是ip地址还是域名，如果是域名，则需要进行DNS查询
5. 网络进程先判断浏览器DNS缓存是否有匹配，没有则查询本地DNS解析器并查询本地缓存，本地DNS解析器查询本地域名服务器，域名服务器迭代查询根域名服务器，顶级域名服务器等，如果返回的记录是a记录直接返回，如果是Cname记录则再次查询，然后返回给本地DNS解析器
6. 建立TCP连接，进行TCP三次握手
7. 建立TLS连接，进行TLS握手
8. 网络进程接收完文档，发送消息通知浏览器进程切换状态，然后发信息通知渲染进程，接收文档
9. 渲染进程解析文档，会建立一个预解析线程，提前扫描文档是否有外联资源需要下载，然后如果遇到同步脚本，则暂停解析，执行脚本；如果文档存在css，则考虑js会获取样式表，会先构建CSSOM；如果是外联同步脚本，会先下载脚本再执行
10. 样式计算：构建出CSSOM树，标准化CSSOM中的属性值，如red，然后根据继承规则等计算出每个节点的具体样式（computed）
11. 布局（layout）：结合CSSOM和DOM生成renderTree，删除不可见元素和不渲染元素，然后进行布局计算，计算每个元素的大小和位置，renderTree上的每一个节点为renderObject（重排会重新走这里）
12. 分层（layer）：renderTree再根据一些特殊的规则，把部分节点生成renderLayer，不符合的跟父节点共用一个renderLayer，最终生成renderLayerTree（layerTree）
13. 提升合成层：renderLayerTree再进一步根据某些特殊的规则，把部分节点提升为合成层（compositingLayer），其他节点跟随父节点共用一个合成层，然后每一个合成层都会有图形层（GraphicsLayer），图形层有一个图形上下文（GraphicsContext），最终生成一个图形层树（GraphicsLayerTree）
14. 图层绘画（paint）：在每一个层中，根据层内的元素，生成绘画记录（paint records）（重绘走这里）
15. 光栅化（raster）：渲染进程主线程完成上述工作后，交由合成线程，合成线程把每一层的内容切分成图块，根据优先级，调用光栅化线程池渲染位图（注意这是在CPU上进行的），位图渲染后放到渲染进程和GPU进程的共享内存中，并且交给GPU进程作为纹理上传到GPU上。
16. 合成：合成线程根据光栅化生成的位图上的信息，构建合成帧（代表页面一个帧的图块内存位置和页面位置信息的集合），然后提交到浏览器进程，浏览器进程通知GPU使用纹理进行合成和绘制，并且把绘制的位图放到后缓冲区（backbuffer）（滚动的时候会由合成线程重新生成合成帧并提交）


### 为什么提升成合成层后会更有效？
- 当发生重绘时，只会针对当前合成层重绘，不需要整个页面重绘
- 当只发生了tranform或者是opacity变化的时候，不需要重绘，合成线程只需要提交新的合成帧，然后GPU使用原有的纹理做GPU擅长的纹理变化和变形，就可以绘制新的帧。所以当提升到合成层之后，部分的动画效果可以直接由合成线程接管，渲染进程主线程阻塞不会影响到动画执行。

### 提升成合成层的注意点
1. 隐式合成：两个重叠的absolute元素会根据z-index进行排序，可是如果下面的那个被强行提升成合成层了，上面那个也会提升为合成层
2. 层爆炸：当一个元素添加了动画后，因为动态交叠不确定，所以z-index比它高的所有元素都会被提升成合成层
3. 层压缩：被动提升成合成层的元素可能被浏览压缩成一个层，减少层爆炸的损耗

### 详细的流程：（部分笔记）
CSSOM+DOM=renderObject->renderTree
renderObject->renderLayer->layerTree
renderLayer->graphicsLayer->graphicsLayerTree

每一个graphicsLayer就是一个图层，使用CPU渲染出每个图层的位图，合成线程把每个图层都分块，传给光栅化线程，光栅化线程根据图块使用GPU命令

> 合成器不是对整个页面进行栅格化，而是将大多数 Web 内容层分解为图块并在每个图块的基础上对层进行栅格化。

GPU加速：旧时只有一个graphicsLayer，渲染成位图后直接展示，现在多了多个层级和GPU合成

GPU进程：因为渲染进程有沙箱的原因，所以无法直接访问系统GPU接口，需要新建一个GPU进程来完成这个任务

> 对于软件光栅化层，绘制目标是在 Renderer 进程和 GPU 进程之间共享的内存中的位图。位图通过上述资源传输机制传递给 GPU 进程。因为软件光栅化可能非常昂贵，所以这种光栅化不会发生在合成器线程本身（它可能会阻止为活动树绘制新帧），而是发生在合成器光栅工作线程中。可以使用多个光栅工作线程来加速软件光栅化；每个工人从优先瓦片队列的前面拉。完成的图块作为纹理上传到 GPU。

光栅化：合成线程把graphicsContext中的内容切分为图块，然后根据优先级，使用光栅化线程池进行位图绘制，并且存放在渲染进程和GPU进程的共享内存中，随后GPU进程把这些位图作为纹理上传到GPU上

> 当图层上面的图块都被栅格化后，合成线程会收集图块上面叫做绘画四边形（draw quads）的信息来构建一个合成帧（compositor frame）。
>  - 绘画四边形：包含图块在内存的位置以及图层合成后图块在页面的位置之类的信息。
>  - 合成帧：代表页面一个帧的内容的绘制四边形集合。

合成线程提交一个合成帧到浏览器进程，浏览器进程收集合成帧并且通知GPU使用纹理进行合成，并且把绘制出来的图片放到后缓冲区，当滚动发生的时候只需要重新提交合成帧就可以了

### renderObject生成renderLayer的规则
  是否是页面的根节点
  是否有css的一些布局属性
  是否透明
  是否有溢出
  是否有css滤镜
  是否包含一个canvas元素使得节点拥有视图上下文
  是否包含一个video元素

### renderLayer提升成compositingLayer的规则
- 3D 或透视变换(perspective transform) CSS 属性
- 使用加速视频解码的 元素 拥有 3D
- (WebGL) 上下文或加速的 2D 上下文的 元素
- 混合插件(如 Flash)
- 对自己的 opacity 做 CSS动画或使用一个动画变换的元素
- 拥有加速 CSS 过滤器的元素
- 元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)
- 元素有一个z-index较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)


### 页面触发事件的处理
浏览器进程接收到用户输入后，会把事件类型和位置传给渲染进程，渲染进程中的合成线程因为知道当前合成帧的位置，所以能推算发生事件的元素是哪一个，然后如果触发事件的元素涉及到事件监听器，就会把事件传递给主线程执行，如果触发事件的元素没有涉及到事件监听器，合成线程就可以直接生成合成帧。
- 问题：如果主线程在事件回调中执行了`prevantDefault`，那就会阻止默认行为的发生，因为合成线程需要等待主线程处理才能知道会不会有阻止代码，所以会产生卡顿。在事件绑定的时候加上`{passive: true}`就可以告诉合成线程不需要等待主线程，就不会有卡顿情况发生了。
- 所以，当我们使用事件委托的时候，就会有可能把实际上不会接收事件的元素也包含在绑定了事件的元素內，合成线程就无法判断当前事件是否需要等待，如果把事件绑到body上，那么所有的事件都会卡顿。

### 事件合并
因为触发频率太高，所以部分事件浏览器会合并到一帧内（rAF）再触发，比如wheel,mouseWheel,mouseMove等事件。如果想要获得一帧内变化多次的具体细节，使用`getCoalesecedEvents`来获取


参考文章：
https://developers.google.com/web/updates/2018/09/inside-browser-part4
https://juejin.cn/post/6844903966573068301
https://zhuanlan.zhihu.com/p/79881310
https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome/

